{"version":3,"file":"resolvers.js","sourceRoot":"","sources":["../../../../../packages/core/testing/src/resolvers.ts"],"names":[],"mappings":";;;;;;;;;;;AAQA,OAAO,EAAC,SAAS,EAAE,SAAS,EAAE,QAAQ,EAAE,IAAI,EAAQ,uBAAuB,IAAI,sBAAsB,EAAC,MAAM,eAAe,CAAC;AAG5H,OAAO,EAAC,iBAAiB,EAAC,MAAM,sBAAsB,CAAC;;AAEvD,MAAM,UAAU,GAAG,IAAI,sBAAsB,EAAE,CAAC;;;;;;;;;;;;;;AAUhD,MAAe,gBAAgB;;yBACT,IAAI,GAAG,EAAkC;wBAC1C,IAAI,GAAG,EAAqB;;;;;;IAI/C,YAAY,CAAC,SAAkD;QAC7D,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;QACvB,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE,QAAQ,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;KAC7E;;;;;IAED,aAAa,CAAC,IAAe;QAC3B,OAAO,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC;KAC/E;;;;;IAED,OAAO,CAAC,IAAe;;QACrB,IAAI,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC;QAE/C,IAAI,CAAC,QAAQ,EAAE;YACb,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YACpC,IAAI,QAAQ,EAAE;;gBACZ,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;gBAC1C,IAAI,QAAQ,EAAE;;oBACZ,MAAM,SAAS,GAAG,IAAI,iBAAiB,EAAE,CAAC;oBAC1C,QAAQ,GAAG,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;iBACtE;aACF;YACD,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;SACnC;QAED,OAAO,QAAQ,CAAC;KACjB;CACF;;;;;;;;;;;;AAGD,MAAM,OAAO,iBAAkB,SAAQ,gBAA2B;;;;IAChE,IAAI,IAAI,KAAK,OAAO,SAAS,CAAC,EAAE;CACjC;AAED,MAAM,OAAO,iBAAkB,SAAQ,gBAA2B;;;;IAChE,IAAI,IAAI,KAAK,OAAO,SAAS,CAAC,EAAE;CACjC;AAED,MAAM,OAAO,YAAa,SAAQ,gBAAsB;;;;IACtD,IAAI,IAAI,KAAK,OAAO,IAAI,CAAC,EAAE;CAC5B;AAED,MAAM,OAAO,gBAAiB,SAAQ,gBAA0B;;;;IAC9D,IAAI,IAAI,KAAK,OAAO,QAAQ,CAAC,EAAE;CAChC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Component, Directive, NgModule, Pipe, Type, ÉµReflectionCapabilities as ReflectionCapabilities} from '@angular/core';\n\nimport {MetadataOverride} from './metadata_override';\nimport {MetadataOverrider} from './metadata_overrider';\n\nconst reflection = new ReflectionCapabilities();\n\n/**\n * Base interface to resolve `@Component`, `@Directive`, `@Pipe` and `@NgModule`.\n */\nexport interface Resolver<T> { resolve(type: Type<any>): T|null; }\n\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nabstract class OverrideResolver<T> implements Resolver<T> {\n  private overrides = new Map<Type<any>, MetadataOverride<T>>();\n  private resolved = new Map<Type<any>, T|null>();\n\n  abstract get type(): any;\n\n  setOverrides(overrides: Array<[Type<any>, MetadataOverride<T>]>) {\n    this.overrides.clear();\n    overrides.forEach(([type, override]) => this.overrides.set(type, override));\n  }\n\n  getAnnotation(type: Type<any>): T|null {\n    return reflection.annotations(type).find(a => a instanceof this.type) || null;\n  }\n\n  resolve(type: Type<any>): T|null {\n    let resolved = this.resolved.get(type) || null;\n\n    if (!resolved) {\n      resolved = this.getAnnotation(type);\n      if (resolved) {\n        const override = this.overrides.get(type);\n        if (override) {\n          const overrider = new MetadataOverrider();\n          resolved = overrider.overrideMetadata(this.type, resolved, override);\n        }\n      }\n      this.resolved.set(type, resolved);\n    }\n\n    return resolved;\n  }\n}\n\n\nexport class DirectiveResolver extends OverrideResolver<Directive> {\n  get type() { return Directive; }\n}\n\nexport class ComponentResolver extends OverrideResolver<Component> {\n  get type() { return Component; }\n}\n\nexport class PipeResolver extends OverrideResolver<Pipe> {\n  get type() { return Pipe; }\n}\n\nexport class NgModuleResolver extends OverrideResolver<NgModule> {\n  get type() { return NgModule; }\n}\n"]}