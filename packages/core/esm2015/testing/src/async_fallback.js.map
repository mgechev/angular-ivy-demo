{"version":3,"file":"async_fallback.js","sourceRoot":"","sources":["../../../../../packages/core/testing/src/async_fallback.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * async has been moved to zone.js\n * this file is for fallback in case old version of zone.js is used\n */\ndeclare var global: any;\n\nconst _global = <any>(typeof window === 'undefined' ? global : window);\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', async(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n *\n */\nexport function asyncFallback(fn: Function): (done: any) => any {\n  // If we're running using the Jasmine test framework, adapt to call the 'done'\n  // function when asynchronous activity is finished.\n  if (_global.jasmine) {\n    // Not using an arrow function to preserve context passed from call site\n    return function(done: any) {\n      if (!done) {\n        // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n        // fake it here and assume sync.\n        done = function() {};\n        done.fail = function(e: any) { throw e; };\n      }\n      runInTestZone(fn, this, done, (err: any) => {\n        if (typeof err === 'string') {\n          return done.fail(new Error(<string>err));\n        } else {\n          done.fail(err);\n        }\n      });\n    };\n  }\n  // Otherwise, return a promise which will resolve when asynchronous activity\n  // is finished. This will be correctly consumed by the Mocha framework with\n  // it('...', async(myFn)); or can be used in a custom framework.\n  // Not using an arrow function to preserve context passed from call site\n  return function() {\n    return new Promise<void>((finishCallback, failCallback) => {\n      runInTestZone(fn, this, finishCallback, failCallback);\n    });\n  };\n}\n\nfunction runInTestZone(\n    fn: Function, context: any, finishCallback: Function, failCallback: Function) {\n  const currentZone = Zone.current;\n  const AsyncTestZoneSpec = (Zone as any)['AsyncTestZoneSpec'];\n  if (AsyncTestZoneSpec === undefined) {\n    throw new Error(\n        'AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n        'Please make sure that your environment includes zone.js/dist/async-test.js');\n  }\n  const ProxyZoneSpec = (Zone as any)['ProxyZoneSpec'] as {\n    get(): {setDelegate(spec: ZoneSpec): void; getDelegate(): ZoneSpec;};\n    assertPresent: () => void;\n  };\n  if (ProxyZoneSpec === undefined) {\n    throw new Error(\n        'ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n        'Please make sure that your environment includes zone.js/dist/proxy.js');\n  }\n  const proxyZoneSpec = ProxyZoneSpec.get();\n  ProxyZoneSpec.assertPresent();\n  // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n  // If we do it in ProxyZone then we will get to infinite recursion.\n  const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n  const previousDelegate = proxyZoneSpec.getDelegate();\n  proxyZone.parent.run(() => {\n    const testZoneSpec: ZoneSpec = new AsyncTestZoneSpec(\n        () => {\n          // Need to restore the original zone.\n          currentZone.run(() => {\n            if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n              // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n              proxyZoneSpec.setDelegate(previousDelegate);\n            }\n            finishCallback();\n          });\n        },\n        (error: any) => {\n          // Need to restore the original zone.\n          currentZone.run(() => {\n            if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n              // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n              proxyZoneSpec.setDelegate(previousDelegate);\n            }\n            failCallback(error);\n          });\n        },\n        'test');\n    proxyZoneSpec.setDelegate(testZoneSpec);\n  });\n  return Zone.current.runGuarded(fn, context);\n}"]}