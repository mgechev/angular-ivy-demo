{"version":3,"file":"inert_body.js","sourceRoot":"","sources":["../../../../../packages/core/src/sanitization/inert_body.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This helper class is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we must use one of three strategies for doing this.\n * Support: Safari 10.x -> XHR strategy\n * Support: Firefox -> DomParser strategy\n * Default: InertDocument strategy\n */\nexport class InertBodyHelper {\n  private inertBodyElement: HTMLElement;\n  private inertDocument: Document;\n\n  constructor(private defaultDoc: Document) {\n    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');\n    this.inertBodyElement = this.inertDocument.body;\n\n    if (this.inertBodyElement == null) {\n      // usually there should be only one body element in the document, but IE doesn't have any, so\n      // we need to create one.\n      const inertHtml = this.inertDocument.createElement('html');\n      this.inertDocument.appendChild(inertHtml);\n      this.inertBodyElement = this.inertDocument.createElement('body');\n      inertHtml.appendChild(this.inertBodyElement);\n    }\n\n    this.inertBodyElement.innerHTML = '<svg><g onload=\"this.parentNode.remove()\"></g></svg>';\n    if (this.inertBodyElement.querySelector && !this.inertBodyElement.querySelector('svg')) {\n      // We just hit the Safari 10.1 bug - which allows JS to run inside the SVG G element\n      // so use the XHR strategy.\n      this.getInertBodyElement = this.getInertBodyElement_XHR;\n      return;\n    }\n\n    this.inertBodyElement.innerHTML =\n        '<svg><p><style><img src=\"</style><img src=x onerror=alert(1)//\">';\n    if (this.inertBodyElement.querySelector && this.inertBodyElement.querySelector('svg img')) {\n      // We just hit the Firefox bug - which prevents the inner img JS from being sanitized\n      // so use the DOMParser strategy, if it is available.\n      // If the DOMParser is not available then we are not in Firefox (Server/WebWorker?) so we\n      // fall through to the default strategy below.\n      if (isDOMParserAvailable()) {\n        this.getInertBodyElement = this.getInertBodyElement_DOMParser;\n        return;\n      }\n    }\n\n    // None of the bugs were hit so it is safe for us to use the default InertDocument strategy\n    this.getInertBodyElement = this.getInertBodyElement_InertDocument;\n  }\n\n  /**\n   * Get an inert DOM element containing DOM created from the dirty HTML string provided.\n   * The implementation of this is determined in the constructor, when the class is instantiated.\n   */\n  getInertBodyElement: (html: string) => HTMLElement | null;\n\n  /**\n   * Use XHR to create and fill an inert body element (on Safari 10.1)\n   * See\n   * https://github.com/cure53/DOMPurify/blob/a992d3a75031cb8bb032e5ea8399ba972bdf9a65/src/purify.js#L439-L449\n   */\n  private getInertBodyElement_XHR(html: string) {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag.\n    html = '<body><remove></remove>' + html + '</body>';\n    try {\n      html = encodeURI(html);\n    } catch (e) {\n      return null;\n    }\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = 'document';\n    xhr.open('GET', 'data:text/html;charset=utf-8,' + html, false);\n    xhr.send(undefined);\n    const body: HTMLBodyElement = xhr.response.body;\n    body.removeChild(body.firstChild !);\n    return body;\n  }\n\n  /**\n   * Use DOMParser to create and fill an inert body element (on Firefox)\n   * See https://github.com/cure53/DOMPurify/releases/tag/0.6.7\n   *\n   */\n  private getInertBodyElement_DOMParser(html: string) {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag.\n    html = '<body><remove></remove>' + html + '</body>';\n    try {\n      const body = new (window as any)\n                       .DOMParser()\n                       .parseFromString(html, 'text/html')\n                       .body as HTMLBodyElement;\n      body.removeChild(body.firstChild !);\n      return body;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Use an HTML5 `template` element, if supported, or an inert body element created via\n   * `createHtmlDocument` to create and fill an inert DOM element.\n   * This is the default sane strategy to use if the browser does not require one of the specialised\n   * strategies above.\n   */\n  private getInertBodyElement_InertDocument(html: string) {\n    // Prefer using <template> element if supported.\n    const templateEl = this.inertDocument.createElement('template');\n    if ('content' in templateEl) {\n      templateEl.innerHTML = html;\n      return templateEl;\n    }\n\n    this.inertBodyElement.innerHTML = html;\n\n    // Support: IE 9-11 only\n    // strip custom-namespaced attributes on IE<=11\n    if ((this.defaultDoc as any).documentMode) {\n      this.stripCustomNsAttrs(this.inertBodyElement);\n    }\n\n    return this.inertBodyElement;\n  }\n\n  /**\n   * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\n   * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.\n   * 'ns1:xlink:foo').\n   *\n   * This is undesirable since we don't want to allow any of these custom attributes. This method\n   * strips them all.\n   */\n  private stripCustomNsAttrs(el: Element) {\n    const elAttrs = el.attributes;\n    // loop backwards so that we can support removals.\n    for (let i = elAttrs.length - 1; 0 < i; i--) {\n      const attrib = elAttrs.item(i);\n      const attrName = attrib !.name;\n      if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {\n        el.removeAttribute(attrName);\n      }\n    }\n    let childNode = el.firstChild as Node | null;\n    while (childNode) {\n      if (childNode.nodeType === Node.ELEMENT_NODE) this.stripCustomNsAttrs(childNode as Element);\n      childNode = childNode.nextSibling;\n    }\n  }\n}\n\n/**\n * We need to determine whether the DOMParser exists in the global context.\n * The try-catch is because, on some browsers, trying to access this property\n * on window can actually throw an error.\n *\n * @suppress {uselessCode}\n */\nfunction isDOMParserAvailable() {\n  try {\n    return !!(window as any).DOMParser;\n  } catch (e) {\n    return false;\n  }\n}\n"]}