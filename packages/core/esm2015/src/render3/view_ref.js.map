{"version":3,"file":"view_ref.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/view_ref.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ApplicationRef} from '../application_ref';\nimport {ChangeDetectorRef as viewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {ViewContainerRef as viewEngine_ViewContainerRef} from '../linker/view_container_ref';\nimport {EmbeddedViewRef as viewEngine_EmbeddedViewRef, InternalViewRef as viewEngine_InternalViewRef} from '../linker/view_ref';\n\nimport {checkNoChanges, checkNoChangesInRootView, detectChanges, detectChangesInRootView, markViewDirty, storeCleanupFn, viewAttached} from './instructions';\nimport {TNode, TNodeType, TViewNode} from './interfaces/node';\nimport {FLAGS, HOST, HOST_NODE, LView, LViewFlags, PARENT, RENDERER_FACTORY} from './interfaces/view';\nimport {destroyLView} from './node_manipulation';\nimport {getNativeByTNode} from './util';\n\n\n\n// Needed due to tsickle downleveling where multiple `implements` with classes creates\n// multiple @extends in Closure annotations, which is illegal. This workaround fixes\n// the multiple @extends by making the annotation @implements instead\nexport interface viewEngine_ChangeDetectorRef_interface extends viewEngine_ChangeDetectorRef {}\n\nexport class ViewRef<T> implements viewEngine_EmbeddedViewRef<T>, viewEngine_InternalViewRef,\n    viewEngine_ChangeDetectorRef_interface {\n  private _appRef: ApplicationRef|null = null;\n  private _viewContainerRef: viewEngine_ViewContainerRef|null = null;\n\n  /**\n   * @internal\n   */\n  public _tViewNode: TViewNode|null = null;\n\n  /**\n   * @internal\n   */\n  public _lView: LView;\n\n  get rootNodes(): any[] {\n    if (this._lView[HOST] == null) {\n      const tView = this._lView[HOST_NODE] as TViewNode;\n      return collectNativeNodes(this._lView, tView, []);\n    }\n    return [];\n  }\n\n  constructor(_lView: LView, private _context: T|null, private _componentIndex: number) {\n    this._lView = _lView;\n  }\n\n  get context(): T { return this._context ? this._context : this._lookUpContext(); }\n\n  get destroyed(): boolean {\n    return (this._lView[FLAGS] & LViewFlags.Destroyed) === LViewFlags.Destroyed;\n  }\n\n  destroy(): void {\n    if (this._appRef) {\n      this._appRef.detachView(this);\n    } else if (this._viewContainerRef && viewAttached(this._lView)) {\n      this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));\n      this._viewContainerRef = null;\n    }\n    destroyLView(this._lView);\n  }\n\n  onDestroy(callback: Function) { storeCleanupFn(this._lView, callback); }\n\n  /**\n   * Marks a view and all of its ancestors dirty.\n   *\n   * It also triggers change detection by calling `scheduleTick` internally, which coalesces\n   * multiple `markForCheck` calls to into one change detection run.\n   *\n   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\n   * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n   * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'my-app',\n   *   template: `Number of ticks: {{numberOfTicks}}`\n   *   changeDetection: ChangeDetectionStrategy.OnPush,\n   * })\n   * class AppComponent {\n   *   numberOfTicks = 0;\n   *\n   *   constructor(private ref: ChangeDetectorRef) {\n   *     setInterval(() => {\n   *       this.numberOfTicks++;\n   *       // the following is required, otherwise the view will not be updated\n   *       this.ref.markForCheck();\n   *     }, 1000);\n   *   }\n   * }\n   * ```\n   */\n  markForCheck(): void { markViewDirty(this._lView); }\n\n  /**\n   * Detaches the view from the change detection tree.\n   *\n   * Detached views will not be checked during change detection runs until they are\n   * re-attached, even if they are dirty. `detach` can be used in combination with\n   * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\n   * detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds. We can do that by detaching\n   * the component's change detector and doing a local check every five seconds.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   // in a real application the returned data will be different every time\n   *   get data() {\n   *     return [1,2,3,4,5];\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'giant-list',\n   *   template: `\n   *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n   *   `,\n   * })\n   * class GiantList {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n   *     ref.detach();\n   *     setInterval(() => {\n   *       this.ref.detectChanges();\n   *     }, 5000);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     <giant-list><giant-list>\n   *   `,\n   * })\n   * class App {\n   * }\n   * ```\n   */\n  detach(): void { this._lView[FLAGS] &= ~LViewFlags.Attached; }\n\n  /**\n   * Re-attaches a view to the change detection tree.\n   *\n   * This can be used to re-attach views that were previously detached from the tree\n   * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example creates a component displaying `live` data. The component will detach\n   * its change detector from the main change detector tree when the component's live property\n   * is set to false.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   data = 1;\n   *\n   *   constructor() {\n   *     setInterval(() => {\n   *       this.data = this.data * 2;\n   *     }, 500);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'live-data',\n   *   inputs: ['live'],\n   *   template: 'Data: {{dataProvider.data}}'\n   * })\n   * class LiveData {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n   *\n   *   set live(value) {\n   *     if (value) {\n   *       this.ref.reattach();\n   *     } else {\n   *       this.ref.detach();\n   *     }\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'my-app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n   *     <live-data [live]=\"live\"><live-data>\n   *   `,\n   * })\n   * class AppComponent {\n   *   live = true;\n   * }\n   * ```\n   */\n  reattach(): void { this._lView[FLAGS] |= LViewFlags.Attached; }\n\n  /**\n   * Checks the view and its children.\n   *\n   * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\n   * local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine, the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds.\n   *\n   * We can do that by detaching the component's change detector and doing a local change detection\n   * check every five seconds.\n   *\n   * See {@link ChangeDetectorRef#detach detach} for more information.\n   */\n  detectChanges(): void {\n    const rendererFactory = this._lView[RENDERER_FACTORY];\n    if (rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n    detectChanges(this.context);\n    if (rendererFactory.end) {\n      rendererFactory.end();\n    }\n  }\n\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * This is used in development mode to verify that running change detection doesn't\n   * introduce other changes.\n   */\n  checkNoChanges(): void { checkNoChanges(this.context); }\n\n  attachToViewContainerRef(vcRef: viewEngine_ViewContainerRef) { this._viewContainerRef = vcRef; }\n\n  detachFromAppRef() { this._appRef = null; }\n\n  attachToAppRef(appRef: ApplicationRef) { this._appRef = appRef; }\n\n  private _lookUpContext(): T {\n    return this._context = this._lView[PARENT] ![this._componentIndex] as T;\n  }\n}\n\n/** @internal */\nexport class RootViewRef<T> extends ViewRef<T> {\n  constructor(public _view: LView) { super(_view, null, -1); }\n\n  detectChanges(): void { detectChangesInRootView(this._view); }\n\n  checkNoChanges(): void { checkNoChangesInRootView(this._view); }\n\n  get context(): T { return null !; }\n}\n\nfunction collectNativeNodes(lView: LView, parentTNode: TNode, result: any[]): any[] {\n  let tNodeChild = parentTNode.child;\n\n  while (tNodeChild) {\n    result.push(getNativeByTNode(tNodeChild, lView));\n    if (tNodeChild.type === TNodeType.ElementContainer) {\n      collectNativeNodes(lView, tNodeChild, result);\n    }\n    tNodeChild = tNodeChild.next;\n  }\n\n  return result;\n}\n"]}