{"version":3,"file":"di.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/di.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getInjectableDef, getInjectorDef} from '../di/defs';\nimport {InjectionToken} from '../di/injection_token';\nimport {Injector} from '../di/injector';\nimport {InjectFlags, injectRootLimpMode, setInjectImplementation} from '../di/injector_compatibility';\nimport {Type} from '../type';\n\nimport {assertDefined, assertEqual} from './assert';\nimport {getComponentDef, getDirectiveDef, getPipeDef} from './definition';\nimport {NG_ELEMENT_ID} from './fields';\nimport {DirectiveDef} from './interfaces/definition';\nimport {NO_PARENT_INJECTOR, NodeInjectorFactory, PARENT_INJECTOR, RelativeInjectorLocation, RelativeInjectorLocationFlags, TNODE, isFactory} from './interfaces/injector';\nimport {AttributeMarker, TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeFlags, TNodeProviderIndexes, TNodeType} from './interfaces/node';\nimport {DECLARATION_VIEW, HOST_NODE, INJECTOR, LView, TData, TVIEW, TView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes} from './node_assert';\nimport {getLView, getPreviousOrParentTNode, setTNodeAndViewData} from './state';\nimport {getParentInjectorIndex, getParentInjectorView, hasParentInjector, isComponent, stringify} from './util';\n\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\nlet includeViewProviders = false;\n\nfunction setIncludeViewProviders(v: boolean): boolean {\n  const oldValue = includeViewProviders;\n  includeViewProviders = v;\n  return oldValue;\n}\n\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nexport function bloomAdd(\n    injectorIndex: number, tView: TView, type: Type<any>| InjectionToken<any>| string): void {\n  ngDevMode && assertEqual(tView.firstTemplatePass, true, 'expected firstTemplatePass to be true');\n  let id: number|undefined =\n      typeof type !== 'string' ? (type as any)[NG_ELEMENT_ID] : type.charCodeAt(0) || 0;\n\n  // Set a unique ID on the directive type, so if something tries to inject the directive,\n  // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n  if (id == null) {\n    id = (type as any)[NG_ELEMENT_ID] = nextNgElementId++;\n  }\n\n  // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n  // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n  const bloomBit = id & BLOOM_MASK;\n\n  // Create a mask that targets the specific bit associated with the directive.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomBit;\n\n  // Use the raw bloomBit number to determine which bloom filter bucket we should check\n  // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc\n  const b7 = bloomBit & 0x80;\n  const b6 = bloomBit & 0x40;\n  const b5 = bloomBit & 0x20;\n  const tData = tView.data as number[];\n\n  if (b7) {\n    b6 ? (b5 ? (tData[injectorIndex + 7] |= mask) : (tData[injectorIndex + 6] |= mask)) :\n         (b5 ? (tData[injectorIndex + 5] |= mask) : (tData[injectorIndex + 4] |= mask));\n  } else {\n    b6 ? (b5 ? (tData[injectorIndex + 3] |= mask) : (tData[injectorIndex + 2] |= mask)) :\n         (b5 ? (tData[injectorIndex + 1] |= mask) : (tData[injectorIndex] |= mask));\n  }\n}\n\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param hostView View where the node is stored\n * @returns Node injector\n */\nexport function getOrCreateNodeInjectorForNode(\n    tNode: TElementNode | TContainerNode | TElementContainerNode, hostView: LView): number {\n  const existingInjectorIndex = getInjectorIndex(tNode, hostView);\n  if (existingInjectorIndex !== -1) {\n    return existingInjectorIndex;\n  }\n\n  const tView = hostView[TVIEW];\n  if (tView.firstTemplatePass) {\n    tNode.injectorIndex = hostView.length;\n    insertBloom(tView.data, tNode);  // foundation for node bloom\n    insertBloom(hostView, null);     // foundation for cumulative bloom\n    insertBloom(tView.blueprint, null);\n\n    ngDevMode && assertEqual(\n                     tNode.flags === 0 || tNode.flags === TNodeFlags.isComponent, true,\n                     'expected tNode.flags to not be initialized');\n  }\n\n  const parentLoc = getParentInjectorLocation(tNode, hostView);\n  const parentIndex = getParentInjectorIndex(parentLoc);\n  const parentLView = getParentInjectorView(parentLoc, hostView);\n\n  const injectorIndex = tNode.injectorIndex;\n\n  // If a parent injector can't be found, its location is set to -1.\n  // In that case, we don't need to set up a cumulative bloom\n  if (hasParentInjector(parentLoc)) {\n    const parentData = parentLView[TVIEW].data as any;\n    // Creates a cumulative bloom filter that merges the parent's bloom filter\n    // and its own cumulative bloom (which contains tokens for all ancestors)\n    for (let i = 0; i < 8; i++) {\n      hostView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n    }\n  }\n\n  hostView[injectorIndex + PARENT_INJECTOR] = parentLoc;\n  return injectorIndex;\n}\n\nfunction insertBloom(arr: any[], footer: TNode | null): void {\n  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\n\n\nexport function getInjectorIndex(tNode: TNode, hostView: LView): number {\n  if (tNode.injectorIndex === -1 ||\n      // If the injector index is the same as its parent's injector index, then the index has been\n      // copied down from the parent node. No injector has been created yet on this node.\n      (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\n      // After the first template pass, the injector index might exist but the parent values\n      // might not have been calculated yet for this instance\n      hostView[tNode.injectorIndex + PARENT_INJECTOR] == null) {\n    return -1;\n  } else {\n    return tNode.injectorIndex;\n  }\n}\n\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * Returns a combination of number of `ViewData` we have to go up and index in that `Viewdata`\n */\nexport function getParentInjectorLocation(tNode: TNode, view: LView): RelativeInjectorLocation {\n  if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n    return tNode.parent.injectorIndex as any;  // ViewOffset is 0, AcrossHostBoundary is 0\n  }\n\n  // For most cases, the parent injector index can be found on the host node (e.g. for component\n  // or container), so this loop will be skipped, but we must keep the loop here to support\n  // the rarer case of deeply nested <ng-template> tags or inline views.\n  let hostTNode = view[HOST_NODE];\n  let viewOffset = 1;\n  while (hostTNode && hostTNode.injectorIndex === -1) {\n    view = view[DECLARATION_VIEW] !;\n    hostTNode = view[HOST_NODE] !;\n    viewOffset++;\n  }\n  const acrossHostBoundary = hostTNode && hostTNode.type === TNodeType.Element ?\n      RelativeInjectorLocationFlags.AcrossHostBoundary :\n      0;\n\n  return hostTNode ?\n      hostTNode.injectorIndex | (viewOffset << RelativeInjectorLocationFlags.ViewOffsetShift) |\n          acrossHostBoundary :\n      -1 as any;\n}\n\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nexport function diPublicInInjector(\n    injectorIndex: number, view: LView, token: InjectionToken<any>| Type<any>): void {\n  bloomAdd(injectorIndex, view[TVIEW], token);\n}\n\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ngComponentDef = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nexport function injectAttributeImpl(tNode: TNode, attrNameToInject: string): string|null {\n  ngDevMode && assertNodeOfPossibleTypes(\n                   tNode, TNodeType.Container, TNodeType.Element, TNodeType.ElementContainer);\n  ngDevMode && assertDefined(tNode, 'expecting tNode');\n  const attrs = tNode.attrs;\n  if (attrs) {\n    for (let i = 0; i < attrs.length; i = i + 2) {\n      const attrName = attrs[i];\n      if (attrName === AttributeMarker.SelectOnly) break;\n      if (attrName == attrNameToInject) {\n        return attrs[i + 1] as string;\n      }\n    }\n  }\n  return null;\n}\n\n\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * @param nodeInjector Node injector where the search should start\n * @param token The token to look for\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n */\nexport function getOrCreateInjectable<T>(\n    tNode: TElementNode | TContainerNode | TElementContainerNode, lView: LView,\n    token: Type<T>| InjectionToken<T>, flags: InjectFlags = InjectFlags.Default,\n    notFoundValue?: any): T|null {\n  const bloomHash = bloomHashBitOrFactory(token);\n  // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n  // so just call the factory function to create it.\n  if (typeof bloomHash === 'function') {\n    const savePreviousOrParentTNode = getPreviousOrParentTNode();\n    const saveLView = getLView();\n    setTNodeAndViewData(tNode, lView);\n    try {\n      const value = bloomHash();\n      if (value == null && !(flags & InjectFlags.Optional)) {\n        throw new Error(`No provider for ${stringify(token)}`);\n      } else {\n        return value;\n      }\n    } finally {\n      setTNodeAndViewData(savePreviousOrParentTNode, saveLView);\n    }\n  } else if (typeof bloomHash == 'number') {\n    // If the token has a bloom hash, then it is a token which could be in NodeInjector.\n\n    // A reference to the previous injector TView that was found while climbing the element injector\n    // tree. This is used to know if viewProviders can be accessed on the current injector.\n    let previousTView: TView|null = null;\n    let injectorIndex = getInjectorIndex(tNode, lView);\n    let parentLocation: RelativeInjectorLocation = NO_PARENT_INJECTOR;\n\n    // If we should skip this injector, or if there is no injector on this node, start by searching\n    // the parent injector.\n    if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {\n      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) :\n                                              lView[injectorIndex + PARENT_INJECTOR];\n\n      if (!shouldSearchParent(flags, parentLocation)) {\n        injectorIndex = -1;\n      } else {\n        previousTView = lView[TVIEW];\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      }\n    }\n\n    // Traverse up the injector tree until we find a potential match or until we know there\n    // *isn't* a match.\n    while (injectorIndex !== -1) {\n      parentLocation = lView[injectorIndex + PARENT_INJECTOR];\n\n      // Check the current injector. If it matches, see if it contains token.\n      const tView = lView[TVIEW];\n      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n        // At this point, we have an injector which *may* contain the token, so we step through\n        // the providers and directives associated with the injector's corresponding node to get\n        // the instance.\n        const instance: T|null =\n            searchTokensOnInjector<T>(injectorIndex, lView, token, previousTView);\n        if (instance !== NOT_FOUND) {\n          return instance;\n        }\n      }\n      if (shouldSearchParent(flags, parentLocation) &&\n          bloomHasToken(bloomHash, injectorIndex, lView)) {\n        // The def wasn't found anywhere on this node, so it was a false positive.\n        // Traverse up the tree and continue searching.\n        previousTView = tView;\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      } else {\n        // If we should not search parent OR If the ancestor bloom filter value does not have the\n        // bit corresponding to the directive we can give up on traversing up to find the specific\n        // injector.\n        injectorIndex = -1;\n      }\n    }\n  }\n\n  if (flags & InjectFlags.Optional && notFoundValue === undefined) {\n    // This must be set or the NullInjector will throw for optional deps\n    notFoundValue = null;\n  }\n\n  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n    const moduleInjector = lView[INJECTOR];\n    if (moduleInjector) {\n      return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n    } else {\n      return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n    }\n  }\n  if (flags & InjectFlags.Optional) {\n    return notFoundValue;\n  } else {\n    throw new Error(`NodeInjector: NOT_FOUND [${stringify(token)}]`);\n  }\n}\n\nconst NOT_FOUND = {};\n\nfunction searchTokensOnInjector<T>(\n    injectorIndex: number, injectorView: LView, token: Type<T>| InjectionToken<T>,\n    previousTView: TView | null) {\n  const currentTView = injectorView[TVIEW];\n  const tNode = currentTView.data[injectorIndex + TNODE] as TNode;\n  // First, we step through providers\n  let canAccessViewProviders = false;\n  // We need to determine if view providers can be accessed by the starting element.\n  // It happens in 2 cases:\n  // 1) On the initial element injector , if we are instantiating a token which can see the\n  // viewProviders of the component of that element. Such token are:\n  // - the component itself (but not other directives)\n  // - viewProviders tokens of the component (but not providers tokens)\n  // 2) Upper in the element injector tree, if the starting element is actually in the view of\n  // the current element. To determine this, we track the transition of view during the climb,\n  // and check the host node of the current view to identify component views.\n  if (previousTView == null && isComponent(tNode) && includeViewProviders ||\n      previousTView != null && previousTView != currentTView &&\n          (currentTView.node == null || currentTView.node.type === TNodeType.Element)) {\n    canAccessViewProviders = true;\n  }\n  const injectableIdx =\n      locateDirectiveOrProvider(tNode, injectorView, token, canAccessViewProviders);\n  if (injectableIdx !== null) {\n    return getNodeInjectable(currentTView.data, injectorView, injectableIdx, tNode as TElementNode);\n  } else {\n    return NOT_FOUND;\n  }\n}\n\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param lView The view we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @returns Index of a found directive or provider, or null when none found.\n */\nexport function locateDirectiveOrProvider<T>(\n    tNode: TNode, lView: LView, token: Type<T>| InjectionToken<T>,\n    canAccessViewProviders: boolean): number|null {\n  const tView = lView[TVIEW];\n  const nodeFlags = tNode.flags;\n  const nodeProviderIndexes = tNode.providerIndexes;\n  const tInjectables = tView.data;\n\n  const startInjectables = nodeProviderIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const startDirectives = nodeFlags >> TNodeFlags.DirectiveStartingIndexShift;\n  const cptViewProvidersCount =\n      nodeProviderIndexes >> TNodeProviderIndexes.CptViewProvidersCountShift;\n  const startingIndex =\n      canAccessViewProviders ? startInjectables : startInjectables + cptViewProvidersCount;\n  const directiveCount = nodeFlags & TNodeFlags.DirectiveCountMask;\n  for (let i = startingIndex; i < startDirectives + directiveCount; i++) {\n    const providerTokenOrDef = tInjectables[i] as InjectionToken<any>| Type<any>| DirectiveDef<any>;\n    if (i < startDirectives && token === providerTokenOrDef ||\n        i >= startDirectives && (providerTokenOrDef as DirectiveDef<any>).type === token) {\n      return i;\n    }\n  }\n  return null;\n}\n\n/**\n* Retrieve or instantiate the injectable from the `lData` at particular `index`.\n*\n* This function checks to see if the value has already been instantiated and if so returns the\n* cached `injectable`. Otherwise if it detects that the value is still a factory it\n* instantiates the `injectable` and caches the value.\n*/\nexport function getNodeInjectable(\n    tData: TData, lData: LView, index: number, tNode: TElementNode): any {\n  let value = lData[index];\n  if (isFactory(value)) {\n    const factory: NodeInjectorFactory = value;\n    if (factory.resolving) {\n      throw new Error(`Circular dep for ${stringify(tData[index])}`);\n    }\n    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n    factory.resolving = true;\n    let previousInjectImplementation;\n    if (factory.injectImpl) {\n      previousInjectImplementation = setInjectImplementation(factory.injectImpl);\n    }\n    const savePreviousOrParentTNode = getPreviousOrParentTNode();\n    const saveLView = getLView();\n    setTNodeAndViewData(tNode, lData);\n    try {\n      value = lData[index] = factory.factory(null, tData, lData, tNode);\n    } finally {\n      if (factory.injectImpl) setInjectImplementation(previousInjectImplementation);\n      setIncludeViewProviders(previousIncludeViewProviders);\n      factory.resolving = false;\n      setTNodeAndViewData(savePreviousOrParentTNode, saveLView);\n    }\n  }\n  return value;\n}\n\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n */\nexport function bloomHashBitOrFactory(token: Type<any>| InjectionToken<any>| string): number|\n    Function|undefined {\n  ngDevMode && assertDefined(token, 'token must be defined');\n  if (typeof token === 'string') {\n    return token.charCodeAt(0) || 0;\n  }\n  const tokenId: number|undefined = (token as any)[NG_ELEMENT_ID];\n  return typeof tokenId === 'number' ? tokenId & BLOOM_MASK : tokenId;\n}\n\nexport function bloomHasToken(\n    bloomHash: number, injectorIndex: number, injectorView: LView | TData) {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash;\n  const b7 = bloomHash & 0x80;\n  const b6 = bloomHash & 0x40;\n  const b5 = bloomHash & 0x20;\n\n  // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:\n  // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.\n  // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.\n  let value: number;\n\n  if (b7) {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6]) :\n                 (b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4]);\n  } else {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2]) :\n                 (b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex]);\n  }\n\n  // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n  // this injector is a potential match.\n  return !!(value & mask);\n}\n\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldSearchParent(flags: InjectFlags, parentLocation: RelativeInjectorLocation): boolean|\n    number {\n  return !(\n      flags & InjectFlags.Self ||\n      (flags & InjectFlags.Host &&\n       ((parentLocation as any as number) & RelativeInjectorLocationFlags.AcrossHostBoundary)));\n}\n\nexport function injectInjector() {\n  const tNode = getPreviousOrParentTNode() as TElementNode | TContainerNode | TElementContainerNode;\n  return new NodeInjector(tNode, getLView());\n}\n\nexport class NodeInjector implements Injector {\n  private _injectorIndex: number;\n\n  constructor(\n      private _tNode: TElementNode|TContainerNode|TElementContainerNode, private _lView: LView) {\n    this._injectorIndex = getOrCreateNodeInjectorForNode(_tNode, _lView);\n  }\n\n  get(token: any): any {\n    const previousTNode = getPreviousOrParentTNode();\n    const previousLView = getLView();\n    setTNodeAndViewData(this._tNode, this._lView);\n    try {\n      return getOrCreateInjectable(this._tNode, this._lView, token);\n    } finally {\n      setTNodeAndViewData(previousTNode, previousLView);\n    }\n  }\n}\n\nexport function getFactoryOf<T>(type: Type<any>): ((type: Type<T>| null) => T)|null {\n  const typeAny = type as any;\n  const def = getComponentDef<T>(typeAny) || getDirectiveDef<T>(typeAny) ||\n      getPipeDef<T>(typeAny) || getInjectableDef<T>(typeAny) || getInjectorDef<T>(typeAny);\n  if (!def || def.factory === undefined) {\n    return null;\n  }\n  return def.factory;\n}\n\nexport function getInheritedFactory<T>(type: Type<any>): (type: Type<T>) => T {\n  const proto = Object.getPrototypeOf(type.prototype).constructor as Type<any>;\n  const factory = getFactoryOf<T>(proto);\n  if (factory !== null) {\n    return factory;\n  } else {\n    // There is no factory defined. Either this was improper usage of inheritance\n    // (no Angular decorator on the superclass) or there is no constructor at all\n    // in the inheritance chain. Since the two cases cannot be distinguished, the\n    // latter has to be assumed.\n    return (t) => new t();\n  }\n}\n"]}