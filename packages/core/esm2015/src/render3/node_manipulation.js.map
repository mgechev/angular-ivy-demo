{"version":3,"file":"node_manipulation.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/node_manipulation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from './assert';\nimport {attachPatchData} from './context_discovery';\nimport {callHooks} from './hooks';\nimport {LContainer, NATIVE, RENDER_PARENT, VIEWS, unusedValueExportToPlacateAjd as unused1} from './interfaces/container';\nimport {TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeFlags, TNodeType, TViewNode, unusedValueExportToPlacateAjd as unused2} from './interfaces/node';\nimport {unusedValueExportToPlacateAjd as unused3} from './interfaces/projection';\nimport {ProceduralRenderer3, RComment, RElement, RNode, RText, Renderer3, isProceduralRenderer, unusedValueExportToPlacateAjd as unused4} from './interfaces/renderer';\nimport {CLEANUP, CONTAINER_INDEX, FLAGS, HEADER_OFFSET, HOST_NODE, HookData, LView, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, TVIEW, unusedValueExportToPlacateAjd as unused5} from './interfaces/view';\nimport {assertNodeType} from './node_assert';\nimport {getNativeByTNode, isLContainer, isRootView, readElementValue, stringify} from './util';\n\nconst unusedValueToPlacateAjd = unused1 + unused2 + unused3 + unused4 + unused5;\n\n/** Retrieves the parent element of a given node. */\nexport function getParentNative(tNode: TNode, currentView: LView): RElement|RComment|null {\n  if (tNode.parent == null) {\n    return getHostNative(currentView);\n  } else {\n    const parentTNode = getFirstParentNative(tNode);\n    return getNativeByTNode(parentTNode, currentView);\n  }\n}\n\n/**\n * Get the first parent of a node that isn't an IcuContainer TNode\n */\nfunction getFirstParentNative(tNode: TNode): TNode {\n  let parent = tNode.parent;\n  while (parent && parent.type === TNodeType.IcuContainer) {\n    parent = parent.parent;\n  }\n  return parent !;\n}\n\n/**\n * Gets the host element given a view. Will return null if the current view is an embedded view,\n * which does not have a host element.\n */\nexport function getHostNative(currentView: LView): RElement|null {\n  const hostTNode = currentView[HOST_NODE] as TElementNode;\n  return hostTNode && hostTNode.type !== TNodeType.View ?\n      (getNativeByTNode(hostTNode, currentView[PARENT] !) as RElement) :\n      null;\n}\n\nexport function getLContainer(tNode: TViewNode, embeddedView: LView): LContainer|null {\n  if (tNode.index === -1) {\n    // This is a dynamically created view inside a dynamic container.\n    // If the host index is -1, the view has not yet been inserted, so it has no parent.\n    const containerHostIndex = embeddedView[CONTAINER_INDEX];\n    return containerHostIndex > -1 ? embeddedView[PARENT] ![containerHostIndex] : null;\n  } else {\n    // This is a inline view node (e.g. embeddedViewStart)\n    return embeddedView[PARENT] ![tNode.parent !.index] as LContainer;\n  }\n}\n\n\n/**\n * Retrieves render parent for a given view.\n * Might be null if a view is not yet attached to any container.\n */\nexport function getContainerRenderParent(tViewNode: TViewNode, view: LView): RElement|null {\n  const container = getLContainer(tViewNode, view);\n  return container ? container[RENDER_PARENT] : null;\n}\n\nconst enum WalkTNodeTreeAction {\n  /** node insert in the native environment */\n  Insert = 0,\n\n  /** node detach from the native environment */\n  Detach = 1,\n\n  /** node destruction using the renderer's API */\n  Destroy = 2,\n}\n\n\n/**\n * Stack used to keep track of projection nodes in walkTNodeTree.\n *\n * This is deliberately created outside of walkTNodeTree to avoid allocating\n * a new array each time the function is called. Instead the array will be\n * re-used by each invocation. This works because the function is not reentrant.\n */\nconst projectionNodeStack: (LView | TNode)[] = [];\n\n/**\n * Walks a tree of TNodes, applying a transformation on the element nodes, either only on the first\n * one found, or on all of them.\n *\n * @param viewToWalk the view to walk\n * @param action identifies the action to be performed on the elements\n * @param renderer the current renderer.\n * @param renderParent Optional the render parent node to be set in all LContainers found,\n * required for action modes Insert and Destroy.\n * @param beforeNode Optional the node before which elements should be added, required for action\n * Insert.\n */\nfunction walkTNodeTree(\n    viewToWalk: LView, action: WalkTNodeTreeAction, renderer: Renderer3,\n    renderParent: RElement | null, beforeNode?: RNode | null) {\n  const rootTNode = viewToWalk[TVIEW].node as TViewNode;\n  let projectionNodeIndex = -1;\n  let currentView = viewToWalk;\n  let tNode: TNode|null = rootTNode.child as TNode;\n  while (tNode) {\n    let nextTNode: TNode|null = null;\n    if (tNode.type === TNodeType.Element) {\n      executeNodeAction(\n          action, renderer, renderParent, getNativeByTNode(tNode, currentView), beforeNode);\n      const nodeOrContainer = currentView[tNode.index];\n      if (isLContainer(nodeOrContainer)) {\n        // This element has an LContainer, and its comment needs to be handled\n        executeNodeAction(action, renderer, renderParent, nodeOrContainer[NATIVE], beforeNode);\n      }\n    } else if (tNode.type === TNodeType.Container) {\n      const lContainer = currentView ![tNode.index] as LContainer;\n      executeNodeAction(action, renderer, renderParent, lContainer[NATIVE], beforeNode);\n\n      if (renderParent) lContainer[RENDER_PARENT] = renderParent;\n\n      if (lContainer[VIEWS].length) {\n        currentView = lContainer[VIEWS][0];\n        nextTNode = currentView[TVIEW].node;\n\n        // When the walker enters a container, then the beforeNode has to become the local native\n        // comment node.\n        beforeNode = lContainer[NATIVE];\n      }\n    } else if (tNode.type === TNodeType.Projection) {\n      const componentView = findComponentView(currentView !);\n      const componentHost = componentView[HOST_NODE] as TElementNode;\n      const head: TNode|null =\n          (componentHost.projection as(TNode | null)[])[tNode.projection as number];\n\n      // Must store both the TNode and the view because this projection node could be nested\n      // deeply inside embedded views, and we need to get back down to this particular nested view.\n      projectionNodeStack[++projectionNodeIndex] = tNode;\n      projectionNodeStack[++projectionNodeIndex] = currentView !;\n      if (head) {\n        currentView = componentView[PARENT] !;\n        nextTNode = currentView[TVIEW].data[head.index] as TNode;\n      }\n    } else {\n      // Otherwise, this is a View or an ElementContainer\n      nextTNode = tNode.child;\n    }\n\n    if (nextTNode === null) {\n      // this last node was projected, we need to get back down to its projection node\n      if (tNode.next === null && (tNode.flags & TNodeFlags.isProjected)) {\n        currentView = projectionNodeStack[projectionNodeIndex--] as LView;\n        tNode = projectionNodeStack[projectionNodeIndex--] as TNode;\n      }\n      nextTNode = tNode.next;\n\n      /**\n       * Find the next node in the TNode tree, taking into account the place where a node is\n       * projected (in the shadow DOM) rather than where it comes from (in the light DOM).\n       *\n       * If there is no sibling node, then it goes to the next sibling of the parent node...\n       * until it reaches rootNode (at which point null is returned).\n       */\n      while (!nextTNode) {\n        // If parent is null, we're crossing the view boundary, so we should get the host TNode.\n        tNode = tNode.parent || currentView[TVIEW].node;\n\n        if (tNode === null || tNode === rootTNode) return null;\n\n        // When exiting a container, the beforeNode must be restored to the previous value\n        if (tNode.type === TNodeType.Container) {\n          currentView = currentView[PARENT] !;\n          beforeNode = currentView[tNode.index][NATIVE];\n        }\n\n        if (tNode.type === TNodeType.View && currentView[NEXT]) {\n          currentView = currentView[NEXT] as LView;\n          nextTNode = currentView[TVIEW].node;\n        } else {\n          nextTNode = tNode.next;\n        }\n      }\n    }\n    tNode = nextTNode;\n  }\n}\n\n/**\n * Given a current view, finds the nearest component's host (LElement).\n *\n * @param lView LView for which we want a host element node\n * @returns The host node\n */\nexport function findComponentView(lView: LView): LView {\n  let rootTNode = lView[HOST_NODE];\n\n  while (rootTNode && rootTNode.type === TNodeType.View) {\n    ngDevMode && assertDefined(lView[PARENT], 'lView.parent');\n    lView = lView[PARENT] !;\n    rootTNode = lView[HOST_NODE];\n  }\n\n  return lView;\n}\n\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction executeNodeAction(\n    action: WalkTNodeTreeAction, renderer: Renderer3, parent: RElement | null,\n    node: RComment | RElement | RText, beforeNode?: RNode | null) {\n  if (action === WalkTNodeTreeAction.Insert) {\n    isProceduralRenderer(renderer !) ?\n        (renderer as ProceduralRenderer3).insertBefore(parent !, node, beforeNode as RNode | null) :\n        parent !.insertBefore(node, beforeNode as RNode | null, true);\n  } else if (action === WalkTNodeTreeAction.Detach) {\n    isProceduralRenderer(renderer !) ?\n        (renderer as ProceduralRenderer3).removeChild(parent !, node) :\n        parent !.removeChild(node);\n  } else if (action === WalkTNodeTreeAction.Destroy) {\n    ngDevMode && ngDevMode.rendererDestroyNode++;\n    (renderer as ProceduralRenderer3).destroyNode !(node);\n  }\n}\n\nexport function createTextNode(value: any, renderer: Renderer3): RText {\n  return isProceduralRenderer(renderer) ? renderer.createText(stringify(value)) :\n                                          renderer.createTextNode(stringify(value));\n}\n\n/**\n * Adds or removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param viewToWalk The view from which elements should be added or removed\n * @param insertMode Whether or not elements should be added (if false, removing)\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nexport function addRemoveViewFromContainer(\n    viewToWalk: LView, insertMode: true, beforeNode: RNode | null): void;\nexport function addRemoveViewFromContainer(viewToWalk: LView, insertMode: false): void;\nexport function addRemoveViewFromContainer(\n    viewToWalk: LView, insertMode: boolean, beforeNode?: RNode | null): void {\n  const renderParent = getContainerRenderParent(viewToWalk[TVIEW].node as TViewNode, viewToWalk);\n  ngDevMode && assertNodeType(viewToWalk[TVIEW].node as TNode, TNodeType.View);\n  if (renderParent) {\n    const renderer = viewToWalk[RENDERER];\n    walkTNodeTree(\n        viewToWalk, insertMode ? WalkTNodeTreeAction.Insert : WalkTNodeTreeAction.Detach, renderer,\n        renderParent, beforeNode);\n  }\n}\n\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nexport function destroyViewTree(rootView: LView): void {\n  // If the view has no children, we can clean it up and return early.\n  if (rootView[TVIEW].childIndex === -1) {\n    return cleanUpView(rootView);\n  }\n  let viewOrContainer: LView|LContainer|null = getLViewChild(rootView);\n\n  while (viewOrContainer) {\n    let next: LView|LContainer|null = null;\n\n    if (viewOrContainer.length >= HEADER_OFFSET) {\n      // If LView, traverse down to child.\n      const view = viewOrContainer as LView;\n      if (view[TVIEW].childIndex > -1) next = getLViewChild(view);\n    } else {\n      // If container, traverse down to its first LView.\n      const container = viewOrContainer as LContainer;\n      if (container[VIEWS].length) next = container[VIEWS][0];\n    }\n\n    if (next == null) {\n      // Only clean up view when moving to the side or up, as destroy hooks\n      // should be called in order from the bottom up.\n      while (viewOrContainer && !viewOrContainer ![NEXT] && viewOrContainer !== rootView) {\n        cleanUpView(viewOrContainer);\n        viewOrContainer = getParentState(viewOrContainer, rootView);\n      }\n      cleanUpView(viewOrContainer || rootView);\n      next = viewOrContainer && viewOrContainer ![NEXT];\n    }\n    viewOrContainer = next;\n  }\n}\n\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param parentView The new parent of the inserted view\n * @param index The index at which to insert the view\n * @param containerIndex The index of the container node, if dynamic\n */\nexport function insertView(\n    lView: LView, lContainer: LContainer, parentView: LView, index: number,\n    containerIndex: number) {\n  const views = lContainer[VIEWS];\n\n  if (index > 0) {\n    // This is a new view, we need to add it to the children.\n    views[index - 1][NEXT] = lView;\n  }\n\n  if (index < views.length) {\n    lView[NEXT] = views[index];\n    views.splice(index, 0, lView);\n  } else {\n    views.push(lView);\n    lView[NEXT] = null;\n  }\n\n  // Dynamically inserted views need a reference to their parent container's host so it's\n  // possible to jump from a view to its container's next when walking the node tree.\n  if (containerIndex > -1) {\n    lView[CONTAINER_INDEX] = containerIndex;\n    lView[PARENT] = parentView;\n  }\n\n  // Notify query that a new view has been added\n  if (lView[QUERIES]) {\n    lView[QUERIES] !.insertView(index);\n  }\n\n  // Sets the attached flag\n  lView[FLAGS] |= LViewFlags.Attached;\n}\n\n/**\n * Detaches a view from a container.\n *\n * This method splices the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @param detached Whether or not this view is already detached.\n */\nexport function detachView(lContainer: LContainer, removeIndex: number, detached: boolean) {\n  const views = lContainer[VIEWS];\n  const viewToDetach = views[removeIndex];\n  if (removeIndex > 0) {\n    views[removeIndex - 1][NEXT] = viewToDetach[NEXT] as LView;\n  }\n  views.splice(removeIndex, 1);\n  if (!detached) {\n    addRemoveViewFromContainer(viewToDetach, false);\n  }\n\n  if (viewToDetach[QUERIES]) {\n    viewToDetach[QUERIES] !.removeView();\n  }\n  viewToDetach[CONTAINER_INDEX] = -1;\n  viewToDetach[PARENT] = null;\n  // Unsets the attached flag\n  viewToDetach[FLAGS] &= ~LViewFlags.Attached;\n}\n\n/**\n * Removes a view from a container, i.e. detaches it and then destroys the underlying LView.\n *\n * @param lContainer The container from which to remove a view\n * @param tContainer The TContainer node associated with the LContainer\n * @param removeIndex The index of the view to remove\n */\nexport function removeView(\n    lContainer: LContainer, containerHost: TElementNode | TContainerNode | TElementContainerNode,\n    removeIndex: number) {\n  const view = lContainer[VIEWS][removeIndex];\n  detachView(lContainer, removeIndex, !!containerHost.detached);\n  destroyLView(view);\n}\n\n/** Gets the child of the given LView */\nexport function getLViewChild(lView: LView): LView|LContainer|null {\n  const childIndex = lView[TVIEW].childIndex;\n  return childIndex === -1 ? null : lView[childIndex];\n}\n\n/**\n * A standalone function which destroys an LView,\n * conducting cleanup (e.g. removing listeners, calling onDestroys).\n *\n * @param view The view to be destroyed.\n */\nexport function destroyLView(view: LView) {\n  const renderer = view[RENDERER];\n  if (isProceduralRenderer(renderer) && renderer.destroyNode) {\n    walkTNodeTree(view, WalkTNodeTreeAction.Destroy, renderer, null);\n  }\n  destroyViewTree(view);\n  // Sets the destroyed flag\n  view[FLAGS] |= LViewFlags.Destroyed;\n}\n\n/**\n * Determines which LViewOrLContainer to jump to when traversing back up the\n * tree in destroyViewTree.\n *\n * Normally, the view's parent LView should be checked, but in the case of\n * embedded views, the container (which is the view node's parent, but not the\n * LView's parent) needs to be checked for a possible next property.\n *\n * @param state The LViewOrLContainer for which we need a parent state\n * @param rootView The rootView, so we don't propagate too far up the view tree\n * @returns The correct parent LViewOrLContainer\n */\nexport function getParentState(state: LView | LContainer, rootView: LView): LView|LContainer|null {\n  let tNode;\n  if (state.length >= HEADER_OFFSET && (tNode = (state as LView) ![HOST_NODE]) &&\n      tNode.type === TNodeType.View) {\n    // if it's an embedded view, the state needs to go up to the container, in case the\n    // container has a next\n    return getLContainer(tNode as TViewNode, state as LView) as LContainer;\n  } else {\n    // otherwise, use parent view for containers or component views\n    return state[PARENT] === rootView ? null : state[PARENT];\n  }\n}\n\n/**\n * Removes all listeners and call all onDestroys in a given view.\n *\n * @param view The LView to clean up\n */\nfunction cleanUpView(viewOrContainer: LView | LContainer): void {\n  if ((viewOrContainer as LView).length >= HEADER_OFFSET) {\n    const view = viewOrContainer as LView;\n    removeListeners(view);\n    executeOnDestroys(view);\n    executePipeOnDestroys(view);\n    // For component views only, the local renderer is destroyed as clean up time.\n    if (view[TVIEW].id === -1 && isProceduralRenderer(view[RENDERER])) {\n      ngDevMode && ngDevMode.rendererDestroy++;\n      (view[RENDERER] as ProceduralRenderer3).destroy();\n    }\n  }\n}\n\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction removeListeners(lView: LView): void {\n  const cleanup = lView[TVIEW].cleanup !;\n  if (cleanup != null) {\n    for (let i = 0; i < cleanup.length - 1; i += 2) {\n      if (typeof cleanup[i] === 'string') {\n        // This is a listener with the native renderer\n        const native = readElementValue(lView[cleanup[i + 1]]);\n        const listener = lView[CLEANUP] ![cleanup[i + 2]];\n        native.removeEventListener(cleanup[i], listener, cleanup[i + 3]);\n        i += 2;\n      } else if (typeof cleanup[i] === 'number') {\n        // This is a listener with renderer2 (cleanup fn can be found by index)\n        const cleanupFn = lView[CLEANUP] ![cleanup[i]];\n        cleanupFn();\n      } else {\n        // This is a cleanup function that is grouped with the index of its context\n        const context = lView[CLEANUP] ![cleanup[i + 1]];\n        cleanup[i].call(context);\n      }\n    }\n    lView[CLEANUP] = null;\n  }\n}\n\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(view: LView): void {\n  const tView = view[TVIEW];\n  let destroyHooks: HookData|null;\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    callHooks(view, destroyHooks);\n  }\n}\n\n/** Calls pipe destroy hooks for this view */\nfunction executePipeOnDestroys(lView: LView): void {\n  const pipeDestroyHooks = lView[TVIEW] && lView[TVIEW].pipeDestroyHooks;\n  if (pipeDestroyHooks) {\n    callHooks(lView !, pipeDestroyHooks);\n  }\n}\n\nexport function getRenderParent(tNode: TNode, currentView: LView): RElement|null {\n  if (canInsertNativeNode(tNode, currentView)) {\n    // If we are asked for a render parent of the root component we need to do low-level DOM\n    // operation as LTree doesn't exist above the topmost host node. We might need to find a render\n    // parent of the topmost host node if the root component injects ViewContainerRef.\n    if (isRootView(currentView)) {\n      return nativeParentNode(currentView[RENDERER], getNativeByTNode(tNode, currentView));\n    }\n\n    const hostTNode = currentView[HOST_NODE];\n\n    const tNodeParent = tNode.parent;\n    if (tNodeParent != null && tNodeParent.type === TNodeType.ElementContainer) {\n      tNode = getHighestElementContainer(tNodeParent);\n    }\n\n    return tNode.parent == null && hostTNode !.type === TNodeType.View ?\n        getContainerRenderParent(hostTNode as TViewNode, currentView) :\n        getParentNative(tNode, currentView) as RElement;\n  }\n  return null;\n}\n\nfunction canInsertNativeChildOfElement(tNode: TNode): boolean {\n  // If the parent is null, then we are inserting across views. This happens when we\n  // insert a root element of the component view into the component host element and it\n  // should always be eager.\n  if (tNode.parent == null ||\n      // We should also eagerly insert if the parent is a regular, non-component element\n      // since we know that this relationship will never be broken.\n      tNode.parent.type === TNodeType.Element && !(tNode.parent.flags & TNodeFlags.isComponent)) {\n    return true;\n  }\n\n  // Parent is a Component. Component's content nodes are not inserted immediately\n  // because they will be projected, and so doing insert at this point would be wasteful.\n  // Since the projection would than move it to its final destination.\n  return false;\n}\n\n/**\n * We might delay insertion of children for a given view if it is disconnected.\n * This might happen for 2 main reasons:\n * - view is not inserted into any container (view was created but not inserted yet)\n * - view is inserted into a container but the container itself is not inserted into the DOM\n * (container might be part of projection or child of a view that is not inserted yet).\n *\n * In other words we can insert children of a given view if this view was inserted into a container\n * and\n * the container itself has its render parent determined.\n */\nfunction canInsertNativeChildOfView(viewTNode: TViewNode, view: LView): boolean {\n  // Because we are inserting into a `View` the `View` may be disconnected.\n  const container = getLContainer(viewTNode, view) !;\n  if (container == null || container[RENDER_PARENT] == null) {\n    // The `View` is not inserted into a `Container` or the parent `Container`\n    // itself is disconnected. So we have to delay.\n    return false;\n  }\n\n  // The parent `Container` is in inserted state, so we can eagerly insert into\n  // this location.\n  return true;\n}\n\n/**\n * Returns whether a native element can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is mare for projection but has not been inserted\n *   into destination.\n *\n\n *\n * @param tNode The tNode of the node that we want to insert.\n * @param currentView Current LView being processed.\n * @return boolean Whether the node should be inserted now (or delayed until later).\n */\nexport function canInsertNativeNode(tNode: TNode, currentView: LView): boolean {\n  let currentNode = tNode;\n  let parent: TNode|null = tNode.parent;\n\n  if (tNode.parent) {\n    if (tNode.parent.type === TNodeType.ElementContainer) {\n      currentNode = getHighestElementContainer(tNode);\n      parent = currentNode.parent;\n    } else if (tNode.parent.type === TNodeType.IcuContainer) {\n      currentNode = getFirstParentNative(currentNode);\n      parent = currentNode.parent;\n    }\n  }\n  if (parent === null) parent = currentView[HOST_NODE];\n\n  if (parent && parent.type === TNodeType.View) {\n    return canInsertNativeChildOfView(parent as TViewNode, currentView);\n  } else {\n    // Parent is a regular element or a component\n    return canInsertNativeChildOfElement(currentNode);\n  }\n}\n\n/**\n * Inserts a native node before another native node for a given parent using {@link Renderer3}.\n * This is a utility function that can be used when native nodes were determined - it abstracts an\n * actual renderer being used.\n */\nexport function nativeInsertBefore(\n    renderer: Renderer3, parent: RElement, child: RNode, beforeNode: RNode | null): void {\n  if (isProceduralRenderer(renderer)) {\n    renderer.insertBefore(parent, child, beforeNode);\n  } else {\n    parent.insertBefore(child, beforeNode, true);\n  }\n}\n\n/**\n * Returns a native parent of a given native node.\n */\nexport function nativeParentNode(renderer: Renderer3, node: RNode): RElement|null {\n  return (isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode) as RElement;\n}\n\n/**\n * Returns a native sibling of a given native node.\n */\nexport function nativeNextSibling(renderer: Renderer3, node: RNode): RNode|null {\n  return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;\n}\n\n/**\n * Appends the `child` element to the `parent`.\n *\n * The element insertion might be delayed {@link canInsertNativeNode}.\n *\n * @param childEl The child that should be appended\n * @param childTNode The TNode of the child element\n * @param currentView The current LView\n * @returns Whether or not the child was appended\n */\nexport function appendChild(\n    childEl: RNode | null = null, childTNode: TNode, currentView: LView): boolean {\n  if (childEl !== null && canInsertNativeNode(childTNode, currentView)) {\n    const renderer = currentView[RENDERER];\n    const parentEl = getParentNative(childTNode, currentView);\n    const parentTNode: TNode = childTNode.parent || currentView[HOST_NODE] !;\n\n    if (parentTNode.type === TNodeType.View) {\n      const lContainer = getLContainer(parentTNode as TViewNode, currentView) as LContainer;\n      const views = lContainer[VIEWS];\n      const index = views.indexOf(currentView);\n      nativeInsertBefore(\n          renderer, lContainer[RENDER_PARENT] !, childEl,\n          getBeforeNodeForView(index, views, lContainer[NATIVE]));\n    } else if (parentTNode.type === TNodeType.ElementContainer) {\n      const renderParent = getRenderParent(childTNode, currentView) !;\n      nativeInsertBefore(renderer, renderParent, childEl, parentEl);\n    } else if (parentTNode.type === TNodeType.IcuContainer) {\n      const icuAnchorNode = getNativeByTNode(childTNode.parent !, currentView) !as RElement;\n      nativeInsertBefore(renderer, parentEl as RElement, childEl, icuAnchorNode);\n    } else {\n      isProceduralRenderer(renderer) ? renderer.appendChild(parentEl !as RElement, childEl) :\n                                       parentEl !.appendChild(childEl);\n    }\n    return true;\n  }\n  return false;\n}\n\n/**\n * Gets the top-level ng-container if ng-containers are nested.\n *\n * @param ngContainer The TNode of the starting ng-container\n * @returns tNode The TNode of the highest level ng-container\n */\nfunction getHighestElementContainer(ngContainer: TNode): TNode {\n  while (ngContainer.parent != null && ngContainer.parent.type === TNodeType.ElementContainer) {\n    ngContainer = ngContainer.parent;\n  }\n  return ngContainer;\n}\n\nexport function getBeforeNodeForView(index: number, views: LView[], containerNative: RComment) {\n  if (index + 1 < views.length) {\n    const view = views[index + 1] as LView;\n    const viewTNode = view[HOST_NODE] as TViewNode;\n    return viewTNode.child ? getNativeByTNode(viewTNode.child, view) : containerNative;\n  } else {\n    return containerNative;\n  }\n}\n\n/**\n * Removes the `child` element from the DOM if not in view and not projected.\n *\n * @param childTNode The TNode of the child to remove\n * @param childEl The child that should be removed\n * @param currentView The current LView\n * @returns Whether or not the child was removed\n */\nexport function removeChild(childTNode: TNode, childEl: RNode | null, currentView: LView): boolean {\n  // We only remove the element if not in View or not projected.\n  if (childEl !== null && canInsertNativeNode(childTNode, currentView)) {\n    const parentNative = getParentNative(childTNode, currentView) !as RElement;\n    const renderer = currentView[RENDERER];\n    isProceduralRenderer(renderer) ? renderer.removeChild(parentNative as RElement, childEl) :\n                                     parentNative !.removeChild(childEl);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Appends a projected node to the DOM, or in the case of a projected container,\n * appends the nodes from all of the container's active views to the DOM.\n *\n * @param projectedTNode The TNode to be projected\n * @param tProjectionNode The projection (ng-content) TNode\n * @param currentView Current LView\n * @param projectionView Projection view (view above current)\n */\nexport function appendProjectedNode(\n    projectedTNode: TNode, tProjectionNode: TNode, currentView: LView,\n    projectionView: LView): void {\n  const native = getNativeByTNode(projectedTNode, projectionView);\n  appendChild(native, tProjectionNode, currentView);\n\n  // the projected contents are processed while in the shadow view (which is the currentView)\n  // therefore we need to extract the view where the host element lives since it's the\n  // logical container of the content projected views\n  attachPatchData(native, projectionView);\n\n  const renderParent = getRenderParent(tProjectionNode, currentView);\n\n  const nodeOrContainer = projectionView[projectedTNode.index];\n  if (projectedTNode.type === TNodeType.Container) {\n    // The node we are adding is a container and we are adding it to an element which\n    // is not a component (no more re-projection).\n    // Alternatively a container is projected at the root of a component's template\n    // and can't be re-projected (as not content of any component).\n    // Assign the final projection location in those cases.\n    nodeOrContainer[RENDER_PARENT] = renderParent;\n    const views = nodeOrContainer[VIEWS];\n    for (let i = 0; i < views.length; i++) {\n      addRemoveViewFromContainer(views[i], true, nodeOrContainer[NATIVE]);\n    }\n  } else {\n    if (projectedTNode.type === TNodeType.ElementContainer) {\n      let ngContainerChildTNode: TNode|null = projectedTNode.child as TNode;\n      while (ngContainerChildTNode) {\n        appendProjectedNode(ngContainerChildTNode, tProjectionNode, currentView, projectionView);\n        ngContainerChildTNode = ngContainerChildTNode.next;\n      }\n    }\n\n    if (isLContainer(nodeOrContainer)) {\n      nodeOrContainer[RENDER_PARENT] = renderParent;\n      appendChild(nodeOrContainer[NATIVE], tProjectionNode, currentView);\n    }\n  }\n}\n"]}