{"version":3,"file":"node_selector_matcher.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/node_selector_matcher.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\nimport {assertDefined, assertNotEqual} from './assert';\nimport {AttributeMarker, TAttributes, TNode, unusedValueExportToPlacateAjd as unused1} from './interfaces/node';\nimport {CssSelector, CssSelectorList, NG_PROJECT_AS_ATTR_NAME, SelectorFlags, unusedValueExportToPlacateAjd as unused2} from './interfaces/projection';\n\nconst unusedValueToPlacateAjd = unused1 + unused2;\n\nfunction isCssClassMatching(nodeClassAttrVal: string, cssClassToMatch: string): boolean {\n  const nodeClassesLen = nodeClassAttrVal.length;\n  const matchIndex = nodeClassAttrVal !.indexOf(cssClassToMatch);\n  const matchEndIdx = matchIndex + cssClassToMatch.length;\n  if (matchIndex === -1                                                  // no match\n      || (matchIndex > 0 && nodeClassAttrVal ![matchIndex - 1] !== ' ')  // no space before\n      ||\n      (matchEndIdx < nodeClassesLen && nodeClassAttrVal ![matchEndIdx] !== ' '))  // no space after\n  {\n    return false;\n  }\n  return true;\n}\n\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data to match\n * @param selector\n * @returns true if node matches the selector.\n */\nexport function isNodeMatchingSelector(tNode: TNode, selector: CssSelector): boolean {\n  ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\n\n  let mode: SelectorFlags = SelectorFlags.ELEMENT;\n  const nodeAttrs = tNode.attrs !;\n  const selectOnlyMarkerIdx = nodeAttrs ? nodeAttrs.indexOf(AttributeMarker.SelectOnly) : -1;\n\n  // When processing \":not\" selectors, we skip to the next \":not\" if the\n  // current one doesn't match\n  let skipToNextSelector = false;\n\n  for (let i = 0; i < selector.length; i++) {\n    const current = selector[i];\n    if (typeof current === 'number') {\n      // If we finish processing a :not selector and it hasn't failed, return false\n      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current as number)) {\n        return false;\n      }\n      // If we are skipping to the next :not() and this mode flag is positive,\n      // it's a part of the current :not() selector, and we should keep skipping\n      if (skipToNextSelector && isPositive(current)) continue;\n      skipToNextSelector = false;\n      mode = (current as number) | (mode & SelectorFlags.NOT);\n      continue;\n    }\n\n    if (skipToNextSelector) continue;\n\n    if (mode & SelectorFlags.ELEMENT) {\n      mode = SelectorFlags.ATTRIBUTE | mode & SelectorFlags.NOT;\n      if (current !== '' && current !== tNode.tagName || current === '' && selector.length === 1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else {\n      const attrName = mode & SelectorFlags.CLASS ? 'class' : current;\n      const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs);\n\n      if (attrIndexInNode === -1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n        continue;\n      }\n\n      const selectorAttrValue = mode & SelectorFlags.CLASS ? current : selector[++i];\n      if (selectorAttrValue !== '') {\n        let nodeAttrValue: string;\n        const maybeAttrName = nodeAttrs[attrIndexInNode];\n        if (selectOnlyMarkerIdx > -1 && attrIndexInNode > selectOnlyMarkerIdx) {\n          nodeAttrValue = '';\n        } else {\n          ngDevMode && assertNotEqual(\n                           maybeAttrName, AttributeMarker.NamespaceURI,\n                           'We do not match directives on namespaced attributes');\n          nodeAttrValue = nodeAttrs[attrIndexInNode + 1] as string;\n        }\n        if (mode & SelectorFlags.CLASS &&\n                !isCssClassMatching(nodeAttrValue as string, selectorAttrValue as string) ||\n            mode & SelectorFlags.ATTRIBUTE && selectorAttrValue !== nodeAttrValue) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n      }\n    }\n  }\n\n  return isPositive(mode) || skipToNextSelector;\n}\n\nfunction isPositive(mode: SelectorFlags): boolean {\n  return (mode & SelectorFlags.NOT) === 0;\n}\n\n/**\n * Examines an attributes definition array from a node to find the index of the\n * attribute with the specified name.\n *\n * NOTE: Will not find namespaced attributes.\n *\n * @param name the name of the attribute to find\n * @param attrs the attribute array to examine\n */\nfunction findAttrIndexInNode(name: string, attrs: TAttributes | null): number {\n  if (attrs === null) return -1;\n  let selectOnlyMode = false;\n  let i = 0;\n  while (i < attrs.length) {\n    const maybeAttrName = attrs[i];\n    if (maybeAttrName === name) {\n      return i;\n    } else if (maybeAttrName === AttributeMarker.NamespaceURI) {\n      // NOTE(benlesh): will not find namespaced attributes. This is by design.\n      i += 4;\n    } else {\n      if (maybeAttrName === AttributeMarker.SelectOnly) {\n        selectOnlyMode = true;\n      }\n      i += selectOnlyMode ? 1 : 2;\n    }\n  }\n\n  return -1;\n}\n\nexport function isNodeMatchingSelectorList(tNode: TNode, selector: CssSelectorList): boolean {\n  for (let i = 0; i < selector.length; i++) {\n    if (isNodeMatchingSelector(tNode, selector[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function getProjectAsAttrValue(tNode: TNode): string|null {\n  const nodeAttrs = tNode.attrs;\n  if (nodeAttrs != null) {\n    const ngProjectAsAttrIdx = nodeAttrs.indexOf(NG_PROJECT_AS_ATTR_NAME);\n    // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n    // (attribute names are stored at even indexes)\n    if ((ngProjectAsAttrIdx & 1) === 0) {\n      return nodeAttrs[ngProjectAsAttrIdx + 1] as string;\n    }\n  }\n  return null;\n}\n\n/**\n * Checks a given node against matching selectors and returns\n * selector index (or 0 if none matched).\n *\n * This function takes into account the ngProjectAs attribute: if present its value will be compared\n * to the raw (un-parsed) CSS selector instead of using standard selector matching logic.\n */\nexport function matchingSelectorIndex(\n    tNode: TNode, selectors: CssSelectorList[], textSelectors: string[]): number {\n  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n  for (let i = 0; i < selectors.length; i++) {\n    // if a node has the ngProjectAs attribute match it against unparsed selector\n    // match a node against a parsed selector only if ngProjectAs attribute is not present\n    if (ngProjectAsAttrVal === textSelectors[i] ||\n        ngProjectAsAttrVal === null && isNodeMatchingSelectorList(tNode, selectors[i])) {\n      return i + 1;  // first matching selector \"captures\" a given node\n    }\n  }\n  return 0;\n}\n"]}