{"version":3,"file":"query.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/interfaces/query.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4EA,aAAa,6BAA6B,GAAG,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {QueryList} from '../../linker';\nimport {Type} from '../../type';\nimport {TContainerNode, TElementContainerNode, TElementNode, TNode} from './node';\n\n/** Used for tracking queries (e.g. ViewChild, ContentChild). */\nexport interface LQueries {\n  /**\n   * The parent LQueries instance.\n   *\n   * When there is a content query, a new LQueries instance is created to avoid mutating any\n   * existing LQueries. After we are done searching content children, the parent property allows\n   * us to traverse back up to the original LQueries instance to continue to search for matches\n   * in the main view.\n   */\n  parent: LQueries|null;\n\n  /**\n   * Ask queries to prepare copy of itself. This assures that tracking new queries on content nodes\n   * doesn't mutate list of queries tracked on a parent node. We will clone LQueries before\n   * constructing content queries.\n   */\n  clone(): LQueries;\n\n  /**\n   * Notify `LQueries` that a new `TNode` has been created and needs to be added to query results\n   * if matching query predicate.\n   */\n  addNode(tNode: TElementNode|TContainerNode|TElementContainerNode): LQueries|null;\n\n  /**\n   * Notify `LQueries` that a new LContainer was added to ivy data structures. As a result we need\n   * to prepare room for views that might be inserted into this container.\n   */\n  container(): LQueries|null;\n\n  /**\n   * Notify `LQueries` that a new `LView` has been created. As a result we need to prepare room\n   * and collect nodes that match query predicate.\n   */\n  createView(): LQueries|null;\n\n  /**\n   * Notify `LQueries` that a new `LView` has been added to `LContainer`. As a result all\n   * the matching nodes from this view should be added to container's queries.\n   */\n  insertView(newViewIndex: number): void;\n\n  /**\n   * Notify `LQueries` that an `LView` has been removed from `LContainer`. As a result all\n   * the matching nodes from this view should be removed from container's queries.\n   */\n  removeView(): void;\n\n  /**\n   * Add additional `QueryList` to track.\n   *\n   * @param queryList `QueryList` to update with changes.\n   * @param predicate Either `Type` or selector array of [key, value] predicates.\n   * @param descend If true the query will recursively apply to the children.\n   * @param read Indicates which token should be read from DI for this query.\n   */\n  track<T>(\n      queryList: QueryList<T>, predicate: Type<any>|string[], descend?: boolean,\n      read?: Type<T>): void;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n"]}