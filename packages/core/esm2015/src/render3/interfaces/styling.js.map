{"version":3,"file":"styling.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/interfaces/styling.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAuLE,OAAc;;IAEd,QAAe;;IAEf,QAAe;;IAEf,WAAkB;;IAElB,sBAA6B;;;IAG7B,4BAAkC;;IAElC,eAAgB;;IAEhB,WAAiB;;;;;;IAMjB,gBAAiB;;IAEjB,yBAA0B;;IAE1B,wBAAyB;;IAEzB,qBAAsB;;IAEtB,sBAAuB;;;IAGvB,kBAAmB;;;IAGnB,kCAAmC;;IAEnC,0BAA2B;;IAE3B,4BAA6B;;IAE7B,cAAe;IACf,iBAAkB;IAClB,cAAe;IACf,2BAA4B;;IAE5B,OAAQ;;IAER,gBAAiB;;;IAEjB,cAA0B","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {StyleSanitizeFn} from '../../sanitization/style_sanitizer';\nimport {RElement} from '../interfaces/renderer';\nimport {PlayerContext} from './player';\n\n\n/**\n * The styling context acts as a styling manifest (shaped as an array) for determining which\n * styling properties have been assigned via the provided `updateStylingMap`, `updateStyleProp`\n * and `updateClassProp` functions. There are also two initialization functions\n * `allocStylingContext` and `createStylingContextTemplate` which are used to initialize\n * and/or clone the context.\n *\n * The context is an array where the first two cells are used for static data (initial styling)\n * and dirty flags / index offsets). The remaining set of cells is used for multi (map) and single\n * (prop) style values.\n *\n * each value from here onwards is mapped as so:\n * [i] = mutation/type flag for the style/class value\n * [i + 1] = prop string (or null incase it has been removed)\n * [i + 2] = value string (or null incase it has been removed)\n *\n * There are three types of styling types stored in this context:\n *   initial: any styles that are passed in once the context is created\n *            (these are stored in the first cell of the array and the first\n *             value of this array is always `null` even if no initial styling exists.\n *             the `null` value is there so that any new styles have a parent to point\n *             to. This way we can always assume that there is a parent.)\n *\n *   single: any styles that are updated using `updateStyleProp` or `updateClassProp` (fixed set)\n *\n *   multi: any styles that are updated using `updateStylingMap` (dynamic set)\n *\n * Note that context is only used to collect style information. Only when `renderStyling`\n * is called is when the styling payload will be rendered (or built as a key/value map).\n *\n * When the context is created, depending on what initial styling values are passed in, the\n * context itself will be pre-filled with slots based on the initial style properties. Say\n * for example we have a series of initial styles that look like so:\n *\n *   style=\"width:100px; height:200px;\"\n *   class=\"foo\"\n *\n * Then the initial state of the context (once initialized) will look like so:\n *\n * ```\n * context = [\n *   element,\n *   playerContext | null,\n *   styleSanitizer | null,\n *   [null, '100px', '200px', true],  // property names are not needed since they have already been\n * written to DOM.\n *\n *   configMasterVal,\n *   1, // this instructs how many `style` values there are so that class index values can be\n * offsetted\n *   { classOne: true, classTwo: false } | 'classOne classTwo' | null // last class value provided\n * into updateStylingMap\n *   { styleOne: '100px', styleTwo: 0 } | null // last style value provided into updateStylingMap\n *\n *   // 8\n *   'width',\n *   pointers(1, 15);  // Point to static `width`: `100px` and multi `width`.\n *   null,\n *\n *   // 11\n *   'height',\n *   pointers(2, 18); // Point to static `height`: `200px` and multi `height`.\n *   null,\n *\n *   // 14\n *   'foo',\n *   pointers(1, 21);  // Point to static `foo`: `true` and multi `foo`.\n *   null,\n *\n *   // 17\n *   'width',\n *   pointers(1, 6);  // Point to static `width`: `100px` and single `width`.\n *   null,\n *\n *   // 21\n *   'height',\n *   pointers(2, 9);  // Point to static `height`: `200px` and single `height`.\n *   null,\n *\n *   // 24\n *   'foo',\n *   pointers(3, 12);  // Point to static `foo`: `true` and single `foo`.\n *   null,\n * ]\n *\n * function pointers(staticIndex: number, dynamicIndex: number) {\n *   // combine the two indices into a single word.\n *   return (staticIndex << StylingFlags.BitCountSize) |\n *     (dynamicIndex << (StylingIndex.BitCountSize + StylingFlags.BitCountSize));\n * }\n * ```\n *\n * The values are duplicated so that space is set aside for both multi ([style] and [class])\n * and single ([style.prop] or [class.named]) values. The respective config values\n * (configValA, configValB, etc...) are a combination of the StylingFlags with two index\n * values: the `initialIndex` (which points to the index location of the style value in\n * the initial styles array in slot 0) and the `dynamicIndex` (which points to the\n * matching single/multi index position in the context array for the same prop).\n *\n * This means that every time `updateStyleProp` or `updateClassProp` are called then they\n * must be called using an index value (not a property string) which references the index\n * value of the initial style prop/class when the context was created. This also means that\n * `updateStyleProp` or `updateClassProp` cannot be called with a new property (only\n * `updateStylingMap` can include new CSS properties that will be added to the context).\n */\nexport interface StylingContext extends Array<InitialStyles|{[key: string]: any}|number|string|\n                                              boolean|RElement|StyleSanitizeFn|PlayerContext|null> {\n  /**\n   * Location of animation context (which contains the active players) for this element styling\n   * context.\n   */\n  [StylingIndex.PlayerContext]: PlayerContext|null;\n\n  /**\n   * The style sanitizer that is used within this context\n   */\n  [StylingIndex.StyleSanitizerPosition]: StyleSanitizeFn|null;\n\n  /**\n   * Location of initial data shared by all instances of this style.\n   */\n  [StylingIndex.InitialStylesPosition]: InitialStyles;\n\n  /**\n   * A numeric value representing the configuration status (whether the context is dirty or not)\n   * mixed together (using bit shifting) with a index value which tells the starting index value\n   * of where the multi style entries begin.\n   */\n  [StylingIndex.MasterFlagPosition]: number;\n\n  /**\n   * A numeric value representing the class index offset value. Whenever a single class is\n   * applied (using `elementClassProp`) it should have an styling index value that doesn't\n   * need to take into account any style values that exist in the context.\n   */\n  [StylingIndex.ClassOffsetPosition]: number;\n\n  /**\n   * Location of element that is used as a target for this context.\n   */\n  [StylingIndex.ElementPosition]: RElement|null;\n\n  /**\n   * The last class value that was interpreted by elementStylingMap. This is cached\n   * So that the algorithm can exit early incase the value has not changed.\n   */\n  [StylingIndex.PreviousOrCachedMultiClassValue]: {[key: string]: any}|string|null;\n\n  /**\n   * The last style value that was interpreted by elementStylingMap. This is cached\n   * So that the algorithm can exit early incase the value has not changed.\n   */\n  [StylingIndex.PreviousMultiStyleValue]: {[key: string]: any}|null;\n}\n\n/**\n * The initial styles is populated whether or not there are any initial styles passed into\n * the context during allocation. The 0th value must be null so that index values of `0` within\n * the context flags can always point to a null value safely when nothing is set.\n *\n * All other entries in this array are of `string` value and correspond to the values that\n * were extracted from the `style=\"\"` attribute in the HTML code for the provided template.\n */\nexport interface InitialStyles extends Array<string|null|boolean> { [0]: null; }\n\n/**\n * Used to set the context to be dirty or not both on the master flag (position 1)\n * or for each single/multi property that exists in the context.\n */\nexport const enum StylingFlags {\n  // Implies no configurations\n  None = 0b00000,\n  // Whether or not the entry or context itself is dirty\n  Dirty = 0b00001,\n  // Whether or not this is a class-based assignment\n  Class = 0b00010,\n  // Whether or not a sanitizer was applied to this property\n  Sanitize = 0b00100,\n  // Whether or not any player builders within need to produce new players\n  PlayerBuildersDirty = 0b01000,\n  // If NgClass is present (or some other class handler) then it will handle the map expressions and\n  // initial classes\n  OnlyProcessSingleClasses = 0b10000,\n  // The max amount of bits used to represent these configuration values\n  BitCountSize = 5,\n  // There are only five bits here\n  BitMask = 0b11111\n}\n\n/** Used as numeric pointer values to determine what cells to update in the `StylingContext` */\nexport const enum StylingIndex {\n  // Position of where the initial styles are stored in the styling context\n  PlayerContext = 0,\n  // Position of where the style sanitizer is stored within the styling context\n  StyleSanitizerPosition = 1,\n  // Position of where the initial styles are stored in the styling context\n  InitialStylesPosition = 2,\n  // Index of location where the start of single properties are stored. (`updateStyleProp`)\n  MasterFlagPosition = 3,\n  // Index of location where the class index offset value is located\n  ClassOffsetPosition = 4,\n  // Position of where the initial styles are stored in the styling context\n  // This index must align with HOST, see interfaces/view.ts\n  ElementPosition = 5,\n  // Position of where the last string-based CSS class value was stored (or a cached version of the\n  // initial styles when a [class] directive is present)\n  PreviousOrCachedMultiClassValue = 6,\n  // Position of where the last string-based CSS class value was stored\n  PreviousMultiStyleValue = 7,\n  // Location of single (prop) value entries are stored within the context\n  SingleStylesStartPosition = 8,\n  // Multi and single entries are stored in `StylingContext` as: Flag; PropertyName;  PropertyValue\n  FlagsOffset = 0,\n  PropertyOffset = 1,\n  ValueOffset = 2,\n  PlayerBuilderIndexOffset = 3,\n  // Size of each multi or single entry (flag + prop + value + playerBuilderIndex)\n  Size = 4,\n  // Each flag has a binary digit length of this value\n  BitCountSize = 14,  // (32 - 4) / 2 = ~14\n  // The binary digit value as a mask\n  BitMask = 0b11111111111111,  // 14 bits\n}\n"]}