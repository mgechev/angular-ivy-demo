{"version":3,"file":"i18n.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/interfaces/i18n.ts"],"names":[],"mappings":";;;;;;;;;;;;;IAsBE,YAAa;IAEb,gBAAiB;IAEjB,cAAmB;IAEnB,aAAsC;IAGtC,SAAc;IAEd,cAAmB;IAEnB,eAAoB;IAEpB,SAAc;IAEd,OAAY;IAEZ,aAAkB;IAElB,kBAAuB;;;;;;;;AAQzB,aAAa,cAAc,GAAmB;IAC5C,MAAM,EAAE,SAAS;CAClB,CAAC;;;;;;AAQF,aAAa,cAAc,GAAmB;IAC5C,MAAM,EAAE,SAAS;CAClB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAmFA,YAAa;IAEb,aAAc;IAEd,cAAkB;IAElB,YAAsC;IAGtC,OAAW;IAEX,OAAW;IAEX,YAAgB;IAEhB,YAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA2HhB,SAAU;IACV,SAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkFZ,aAAa,6BAA6B,GAAG,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * `I18nMutateOpCode` defines OpCodes for `I18nMutateOpCodes` array.\n *\n * OpCodes contain three parts:\n *  1) Parent node index offset.\n *  2) Reference node index offset.\n *  3) The OpCode to execute.\n *\n * See: `I18nCreateOpCodes` for example of usage.\n */\nimport {SanitizerFn} from './sanitization';\n\nexport const enum I18nMutateOpCode {\n  /// Stores shift amount for bits 17-3 that contain reference index.\n  SHIFT_REF = 3,\n  /// Stores shift amount for bits 31-17 that contain parent index.\n  SHIFT_PARENT = 17,\n  /// Mask for OpCode\n  MASK_OPCODE = 0b111,\n  /// Mask for reference index.\n  MASK_REF = ((2 ^ 16) - 1) << SHIFT_REF,\n\n  /// OpCode to select a node. (next OpCode will contain the operation.)\n  Select = 0b000,\n  /// OpCode to append the current node to `PARENT`.\n  AppendChild = 0b001,\n  /// OpCode to insert the current node to `PARENT` before `REF`.\n  InsertBefore = 0b010,\n  /// OpCode to remove the `REF` node from `PARENT`.\n  Remove = 0b011,\n  /// OpCode to set the attribute of a node.\n  Attr = 0b100,\n  /// OpCode to simulate elementEnd()\n  ElementEnd = 0b101,\n  /// OpCode to read the remove OpCodes for the nested ICU\n  RemoveNestedIcu = 0b110,\n}\n\n/**\n * Marks that the next string is for element.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const ELEMENT_MARKER: ELEMENT_MARKER = {\n  marker: 'element'\n};\nexport interface ELEMENT_MARKER { marker: 'element'; }\n\n/**\n * Marks that the next string is for comment.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const COMMENT_MARKER: COMMENT_MARKER = {\n  marker: 'comment'\n};\n\nexport interface COMMENT_MARKER { marker: 'comment'; }\n\n/**\n * Array storing OpCode for dynamically creating `i18n` blocks.\n *\n * Example:\n * ```\n * <I18nCreateOpCode>[\n *   // For adding text nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createTextNode('abc');\n *   //   lView[1].insertBefore(node, lView[2]);\n *   'abc', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createTextNode('xyz');\n *   //   lView[1].appendChild(node);\n *   'xyz', 1 << SHIFT_PARENT | AppendChild,\n *\n *   // For adding element nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createElement('div');\n *   //   lView[1].insertBefore(node, lView[2]);\n *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createElement('div');\n *   //   lView[1].appendChild(node);\n *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | AppendChild,\n *\n *   // For adding comment nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createComment('');\n *   //   lView[1].insertBefore(node, lView[2]);\n *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createComment('');\n *   //   lView[1].appendChild(node);\n *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | AppendChild,\n *\n *   // For moving existing nodes to a different location\n *   // --------------------------------------------------\n *   // Equivalent to:\n *   //   const node = lView[1];\n *   //   lView[2].insertBefore(node, lView[3]);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 3 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lView[1];\n *   //   lView[2].appendChild(node);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | AppendChild,\n *\n *   // For removing existing nodes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   removeChild(tView.data(1), node, lView);\n *   1 << SHIFT_REF | Remove,\n *\n *   // For writing attributes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   node.setAttribute('attr', 'value');\n *   1 << SHIFT_REF | Select, 'attr', 'value'\n *            // NOTE: Select followed by two string (vs select followed by OpCode)\n * ];\n * ```\n * NOTE:\n *   - `index` is initial location where the extra nodes should be stored in the EXPANDO section of\n * `LVIewData`.\n *\n * See: `applyI18nCreateOpCodes`;\n */\nexport interface I18nMutateOpCodes extends Array<number|string|ELEMENT_MARKER|COMMENT_MARKER|null> {\n}\n\nexport const enum I18nUpdateOpCode {\n  /// Stores shift amount for bits 17-2 that contain reference index.\n  SHIFT_REF = 2,\n  /// Stores shift amount for bits 31-17 that contain which ICU in i18n block are we referring to.\n  SHIFT_ICU = 17,\n  /// Mask for OpCode\n  MASK_OPCODE = 0b11,\n  /// Mask for reference index.\n  MASK_REF = ((2 ^ 16) - 1) << SHIFT_REF,\n\n  /// OpCode to update a text node.\n  Text = 0b00,\n  /// OpCode to update a attribute of a node.\n  Attr = 0b01,\n  /// OpCode to switch the current ICU case.\n  IcuSwitch = 0b10,\n  /// OpCode to update the current ICU case.\n  IcuUpdate = 0b11,\n}\n\n/**\n * Stores DOM operations which need to be applied to update DOM render tree due to changes in\n * expressions.\n *\n * The basic idea is that `i18nExp` OpCodes capture expression changes and update a change\n * mask bit. (Bit 1 for expression 1, bit 2 for expression 2 etc..., bit 32 for expression 32 and\n * higher.) The OpCodes then compare its own change mask against the expression change mask to\n * determine if the OpCodes should execute.\n *\n * These OpCodes can be used by both the i18n block as well as ICU sub-block.\n *\n * ## Example\n *\n * Assume\n * ```\n *   if (rf & RenderFlags.Update) {\n *    i18nExp(bind(ctx.exp1)); // If changed set mask bit 1\n *    i18nExp(bind(ctx.exp2)); // If changed set mask bit 2\n *    i18nExp(bind(ctx.exp3)); // If changed set mask bit 3\n *    i18nExp(bind(ctx.exp4)); // If changed set mask bit 4\n *    i18nApply(0);            // Apply all changes by executing the OpCodes.\n *  }\n * ```\n * We can assume that each call to `i18nExp` sets an internal `changeMask` bit depending on the\n * index of `i18nExp`.\n *\n * OpCodes\n * ```\n * <I18nUpdateOpCodes>[\n *   // The following OpCodes represent: `<div i18n-title=\"pre{{exp1}}in{{exp2}}post\">`\n *   // If `changeMask & 0b11`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `7` values and start processing next OpCodes.\n *   0b11, 7,\n *   // Concatenate `newValue = 'pre'+lView[bindIndex-4]+'in'+lView[bindIndex-3]+'post';`.\n *   'pre', -4, 'in', -3, 'post',\n *   // Update attribute: `elementAttribute(1, 'title', sanitizerFn(newValue));`\n *   1 << SHIFT_REF | Attr, 'title', sanitizerFn,\n *\n *   // The following OpCodes represent: `<div i18n>Hello {{exp3}}!\">`\n *   // If `changeMask & 0b100`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b100, 4,\n *   // Concatenate `newValue = 'Hello ' + lView[bindIndex -2] + '!';`.\n *   'Hello ', -2, '!',\n *   // Update text: `lView[1].textContent = newValue;`\n *   1 << SHIFT_REF | Text,\n *\n *   // The following OpCodes represent: `<div i18n>{exp4, plural, ... }\">`\n *   // If `changeMask & 0b1000`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b1000, 4,\n *   // Concatenate `newValue = lView[bindIndex -1];`.\n *   -1,\n *   // Switch ICU: `icuSwitchCase(lView[1], 0, newValue);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuSwitch,\n *\n *   // Note `changeMask & -1` is always true, so the IcuUpdate will always execute.\n *   -1, 1,\n *   // Update ICU: `icuUpdateCase(lView[1], 0);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuUpdate,\n *\n * ];\n * ```\n *\n */\nexport interface I18nUpdateOpCodes extends Array<string|number|SanitizerFn|null> {}\n\n/**\n * Store information for the i18n translation block.\n */\nexport interface TI18n {\n  /**\n   * Number of slots to allocate in expando.\n   *\n   * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When\n   * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can\n   * write into them.\n   */\n  vars: number;\n\n  /**\n   * Index in EXPANDO where the i18n stores its DOM nodes.\n   *\n   * When the bindings are processed by the `i18nEnd` instruction it is necessary to know where the\n   * newly created DOM nodes will be inserted.\n   */\n  expandoStartIndex: number;\n\n  /**\n   * A set of OpCodes which will create the Text Nodes and ICU anchors for the translation blocks.\n   *\n   * NOTE: The ICU anchors are filled in with ICU Update OpCode.\n   */\n  create: I18nMutateOpCodes;\n\n  /**\n   * A set of OpCodes which will be executed on each change detection to determine if any changes to\n   * DOM are required.\n   */\n  update: I18nUpdateOpCodes;\n\n  /**\n   * A list of ICUs in a translation block (or `null` if block has no ICUs).\n   *\n   * Example:\n   * Given: `<div i18n>You have {count, plural, ...} and {state, switch, ...}</div>`\n   * There would be 2 ICUs in this array.\n   *   1. `{count, plural, ...}`\n   *   2. `{state, switch, ...}`\n   */\n  icus: TIcu[]|null;\n}\n\n/**\n * Defines the ICU type of `select` or `plural`\n */\nexport const enum IcuType {\n  select = 0,\n  plural = 1,\n}\n\nexport interface TIcu {\n  /**\n   * Defines the ICU type of `select` or `plural`\n   */\n  type: IcuType;\n\n  /**\n   * Number of slots to allocate in expando for each case.\n   *\n   * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When\n   * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can\n   * write into them.\n   */\n  vars: number[];\n\n  /**\n   * An optional array of child/sub ICUs.\n   *\n   * In case of nested ICUs such as:\n   * ```\n   * {�0�, plural,\n   *   =0 {zero}\n   *   other {�0� {�1�, select,\n   *                     cat {cats}\n   *                     dog {dogs}\n   *                     other {animals}\n   *                   }!\n   *   }\n   * }\n   * ```\n   * When the parent ICU is changing it must clean up child ICUs as well. For this reason it needs\n   * to know which child ICUs to run clean up for as well.\n   *\n   * In the above example this would be:\n   * ```\n   * [\n   *   [],   // `=0` has no sub ICUs\n   *   [1],  // `other` has one subICU at `1`st index.\n   * ]\n   * ```\n   *\n   * The reason why it is Array of Arrays is because first array represents the case, and second\n   * represents the child ICUs to clean up. There may be more than one child ICUs per case.\n   */\n  childIcus: number[][];\n\n  /**\n   * Index in EXPANDO where the i18n stores its DOM nodes.\n   *\n   * When the bindings are processed by the `i18nEnd` instruction it is necessary to know where the\n   * newly created DOM nodes will be inserted.\n   */\n  expandoStartIndex: number;\n\n  /**\n   * A list of case values which the current ICU will try to match.\n   *\n   * The last value is `other`\n   */\n  cases: any[];\n\n  /**\n   * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n   */\n  create: I18nMutateOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n   */\n  remove: I18nMutateOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.\n   */\n  update: I18nUpdateOpCodes[];\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n"]}