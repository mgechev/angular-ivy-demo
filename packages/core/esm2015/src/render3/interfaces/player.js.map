{"version":3,"file":"player.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/interfaces/player.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAsBE,QAAS;IACT,QAAS;IACT,QAAS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAyCkB,UAAW,EAAE,UAAW,EAAE,SAAU,EAAE,aAAc,EAAE,cAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAmChG,yBAA0B;;;IAG1B,gCAAiC;;IAEjC,yBAA0B;;;IAG1B,gCAAiC;;IAEjC,yBAA0B;;IAE1B,8BAA+B;;IAE/B,oCAAqC;;IAErC,mCAAoC;;IAEpC,uBAAwB","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A shared interface which contains an animation player\n */\nexport interface Player {\n  parent?: Player|null;\n  state: PlayState;\n  play(): void;\n  pause(): void;\n  finish(): void;\n  destroy(): void;\n  addEventListener(state: PlayState|string, cb: (data?: any) => any): void;\n}\n\nexport const enum BindingType {\n  Unset = 0,\n  Class = 1,\n  Style = 2,\n}\n\nexport interface BindingStore { setValue(prop: string, value: any): void; }\n\n/**\n * Defines the shape which produces the Player.\n *\n * Used to produce a player that will be placed on an element that contains\n * styling bindings that make use of the player. This function is designed\n * to be used with `PlayerFactory`.\n */\nexport interface PlayerFactoryBuildFn {\n  (element: HTMLElement, type: BindingType, values: {[key: string]: any}, isFirstRender: boolean,\n   currentPlayer: Player|null): Player|null;\n}\n\n/**\n * Used as a reference to build a player from a styling template binding\n * (`[style]` and `[class]`).\n *\n * The `fn` function will be called once any styling-related changes are\n * evaluated on an element and is expected to return a player that will\n * be then run on the element.\n *\n * `[style]`, `[style.prop]`, `[class]` and `[class.name]` template bindings\n * all accept a `PlayerFactory` as input and this player factories.\n */\nexport interface PlayerFactory { '__brand__': 'Brand for PlayerFactory that nothing will match'; }\n\nexport interface PlayerBuilder extends BindingStore {\n  buildPlayer(currentPlayer: Player|null, isFirstRender: boolean): Player|undefined|null;\n}\n\n/**\n * The state of a given player\n *\n * Do not change the increasing nature of the numbers since the player\n * code may compare state by checking if a number is higher or lower than\n * a certain numeric value.\n */\nexport const enum PlayState {Pending = 0, Running = 1, Paused = 2, Finished = 100, Destroyed = 200}\n\n/**\n * The context that stores all the active players and queued player factories present on an element.\n */\nexport interface PlayerContext extends Array<null|number|Player|PlayerBuilder> {\n  [PlayerIndex.NonBuilderPlayersStart]: number;\n  [PlayerIndex.ClassMapPlayerBuilderPosition]: PlayerBuilder|null;\n  [PlayerIndex.ClassMapPlayerPosition]: Player|null;\n  [PlayerIndex.StyleMapPlayerBuilderPosition]: PlayerBuilder|null;\n  [PlayerIndex.StyleMapPlayerPosition]: Player|null;\n}\n\n/**\n * Designed to be used as an injection service to capture all animation players.\n *\n * When present all animation players will be passed into the flush method below.\n * This feature is designed to service application-wide animation testing, live\n * debugging as well as custom animation choreographing tools.\n */\nexport interface PlayerHandler {\n  /**\n   * Designed to kick off the player at the end of change detection\n   */\n  flushPlayers(): void;\n\n  /**\n   * @param player The player that has been scheduled to run within the application.\n   * @param context The context as to where the player was bound to\n   */\n  queuePlayer(player: Player, context: ComponentInstance|DirectiveInstance|HTMLElement): void;\n}\n\nexport const enum PlayerIndex {\n  // The position where the index that reveals where players start in the PlayerContext\n  NonBuilderPlayersStart = 0,\n  // The position where the player builder lives (which handles {key:value} map expression) for\n  // classes\n  ClassMapPlayerBuilderPosition = 1,\n  // The position where the last player assigned to the class player builder is stored\n  ClassMapPlayerPosition = 2,\n  // The position where the player builder lives (which handles {key:value} map expression) for\n  // styles\n  StyleMapPlayerBuilderPosition = 3,\n  // The position where the last player assigned to the style player builder is stored\n  StyleMapPlayerPosition = 4,\n  // The position where any player builders start in the PlayerContext\n  PlayerBuildersStartPosition = 1,\n  // The position where non map-based player builders start in the PlayerContext\n  SinglePlayerBuildersStartPosition = 5,\n  // For each player builder there is a player in the player context (therefore size = 2)\n  PlayerAndPlayerBuildersTupleSize = 2,\n  // The player exists next to the player builder in the list\n  PlayerOffsetPosition = 1,\n}\n\nexport declare type ComponentInstance = {};\nexport declare type DirectiveInstance = {};\n"]}