{"version":3,"file":"container.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/interfaces/container.ts"],"names":[],"mappings":";;;;;;;;;;;AAWA,OAAO,EAAC,IAAI,EAAS,IAAI,EAAE,MAAM,EAAE,OAAO,EAAC,MAAM,QAAQ,CAAC;;;;;;AAQ1D,aAAa,YAAY,GAAG,CAAC,CAAC;;AAC9B,aAAa,KAAK,GAAG,CAAC,CAAC;;AAGvB,aAAa,MAAM,GAAG,CAAC,CAAC;;AACxB,aAAa,aAAa,GAAG,CAAC,CAAC;;;;;;;;;;;;AAsF/B,aAAa,6BAA6B,GAAG,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {LQueries} from './query';\nimport {RComment, RElement} from './renderer';\nimport {StylingContext} from './styling';\nimport {HOST, LView, NEXT, PARENT, QUERIES} from './view';\n\n\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\nexport const ACTIVE_INDEX = 0;\nexport const VIEWS = 1;\n// PARENT, NEXT, QUERIES, and HOST are indices 2, 3, 4, and 5.\n// As we already have these constants in LView, we don't need to re-create them.\nexport const NATIVE = 6;\nexport const RENDER_PARENT = 7;\n\n/**\n * The state associated with a container.\n *\n * This is an array so that its structure is closer to LView. This helps\n * when traversing the view tree (which is a mix of containers and component\n * views), so we can jump to viewOrContainer[NEXT] in the same way regardless\n * of type.\n */\nexport interface LContainer extends Array<any> {\n  /**\n   * The next active index in the views array to read or write to. This helps us\n   * keep track of where we are in the views array.\n   * In the case the LContainer is created for a ViewContainerRef,\n   * it is set to null to identify this scenario, as indices are \"absolute\" in that case,\n   * i.e. provided directly by the user of the ViewContainerRef API.\n   */\n  [ACTIVE_INDEX]: number;\n\n  /**\n   * A list of the container's currently active child views. Views will be inserted\n   * here as they are added and spliced from here when they are removed. We need\n   * to keep a record of current views so we know which views are already in the DOM\n   * (and don't need to be re-added) and so we can remove views from the DOM when they\n   * are no longer required.\n   */\n  [VIEWS]: LView[];\n\n  /**\n   * Access to the parent view is necessary so we can propagate back\n   * up from inside a container to parent[NEXT].\n   */\n  [PARENT]: LView|null;\n\n  /**\n   * This allows us to jump from a container to a sibling container or component\n   * view with the same parent, so we can remove listeners efficiently.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /**\n   * Queries active for this container - all the views inserted to / removed from\n   * this container are reported to queries referenced here.\n   */\n  [QUERIES]: LQueries|null;\n\n  /**\n   * The host element of this LContainer.\n   *\n   * The host could be an LView if this container is on a component node.\n   * In that case, the component LView is its HOST.\n   *\n   * It could also be a styling context if this is a node with a style/class\n   * binding.\n   */\n  [HOST]: RElement|RComment|StylingContext|LView;\n\n  /** The comment element that serves as an anchor for this LContainer. */\n  [NATIVE]: RComment;\n\n  /**\n   * Parent Element which will contain the location where all of the views will be\n   * inserted into to.\n   *\n   * If `renderParent` is `null` it is headless. This means that it is contained\n   * in another view which in turn is contained in another container and\n   * therefore it does not yet have its own parent.\n   *\n   * If `renderParent` is not `null` then it may be:\n   * - same as `tContainerNode.parent` in which case it is just a normal container.\n   * - different from `tContainerNode.parent` in which case it has been re-projected.\n   *   In other words `tContainerNode.parent` is logical parent where as\n   *   `tContainerNode.projectedParent` is render parent.\n   *\n   * When views are inserted into `LContainer` then `renderParent` is:\n   * - `null`, we are in a view, keep going up a hierarchy until actual\n   *   `renderParent` is found.\n   * - not `null`, then use the `projectedParent.native` as the `RElement` to insert\n   * views into.\n   */\n  [RENDER_PARENT]: RElement|null;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n"]}