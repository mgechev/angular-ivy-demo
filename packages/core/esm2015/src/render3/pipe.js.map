{"version":3,"file":"pipe.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/pipe.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {PipeTransform} from '../change_detection/pipe_transform';\n\nimport {load, store} from './instructions';\nimport {PipeDef, PipeDefList} from './interfaces/definition';\nimport {HEADER_OFFSET, TVIEW} from './interfaces/view';\nimport {pureFunction1, pureFunction2, pureFunction3, pureFunction4, pureFunctionV} from './pure_function';\nimport {getLView} from './state';\n\n/**\n * Create a pipe.\n *\n * @param index Pipe index where the pipe will be stored.\n * @param pipeName The name of the pipe\n * @returns T the instance of the pipe.\n */\nexport function pipe(index: number, pipeName: string): any {\n  const tView = getLView()[TVIEW];\n  let pipeDef: PipeDef<any>;\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  if (tView.firstTemplatePass) {\n    pipeDef = getPipeDef(pipeName, tView.pipeRegistry);\n    tView.data[adjustedIndex] = pipeDef;\n    if (pipeDef.onDestroy) {\n      (tView.pipeDestroyHooks || (tView.pipeDestroyHooks = [\n       ])).push(adjustedIndex, pipeDef.onDestroy);\n    }\n  } else {\n    pipeDef = tView.data[adjustedIndex] as PipeDef<any>;\n  }\n\n  const pipeInstance = pipeDef.factory(null);\n  store(index, pipeInstance);\n  return pipeInstance;\n}\n\n/**\n * Searches the pipe registry for a pipe with the given name. If one is found,\n * returns the pipe. Otherwise, an error is thrown because the pipe cannot be resolved.\n *\n * @param name Name of pipe to resolve\n * @param registry Full list of available pipes\n * @returns Matching PipeDef\n */\nfunction getPipeDef(name: string, registry: PipeDefList | null): PipeDef<any> {\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const pipeDef = registry[i];\n      if (name === pipeDef.name) {\n        return pipeDef;\n      }\n    }\n  }\n  throw new Error(`Pipe with name '${name}' not found!`);\n}\n\n/**\n * Invokes a pipe with 1 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n */\nexport function pipeBind1(index: number, slotOffset: number, v1: any): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ? pureFunction1(slotOffset, pipeInstance.transform, v1, pipeInstance) :\n                         pipeInstance.transform(v1);\n}\n\n/**\n * Invokes a pipe with 2 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n */\nexport function pipeBind2(index: number, slotOffset: number, v1: any, v2: any): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ? pureFunction2(slotOffset, pipeInstance.transform, v1, v2, pipeInstance) :\n                         pipeInstance.transform(v1, v2);\n}\n\n/**\n * Invokes a pipe with 3 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 4rd argument to {@link PipeTransform#transform}.\n */\nexport function pipeBind3(index: number, slotOffset: number, v1: any, v2: any, v3: any): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ?\n      pureFunction3(slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) :\n      pipeInstance.transform(v1, v2, v3);\n}\n\n/**\n * Invokes a pipe with 4 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 3rd argument to {@link PipeTransform#transform}.\n * @param v4 4th argument to {@link PipeTransform#transform}.\n */\nexport function pipeBind4(\n    index: number, slotOffset: number, v1: any, v2: any, v3: any, v4: any): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ?\n      pureFunction4(slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) :\n      pipeInstance.transform(v1, v2, v3, v4);\n}\n\n/**\n * Invokes a pipe with variable number of arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\n */\nexport function pipeBindV(index: number, slotOffset: number, values: any[]): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ? pureFunctionV(slotOffset, pipeInstance.transform, values, pipeInstance) :\n                         pipeInstance.transform.apply(pipeInstance, values);\n}\n\nfunction isPure(index: number): boolean {\n  return (<PipeDef<any>>getLView()[TVIEW].data[index + HEADER_OFFSET]).pure;\n}\n"]}