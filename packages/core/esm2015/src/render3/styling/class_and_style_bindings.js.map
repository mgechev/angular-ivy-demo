{"version":3,"file":"class_and_style_bindings.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/styling/class_and_style_bindings.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {StyleSanitizeFn} from '../../sanitization/style_sanitizer';\nimport {InitialStylingFlags} from '../interfaces/definition';\nimport {BindingStore, BindingType, Player, PlayerBuilder, PlayerFactory, PlayerIndex} from '../interfaces/player';\nimport {Renderer3, RendererStyleFlags3, isProceduralRenderer} from '../interfaces/renderer';\nimport {InitialStyles, StylingContext, StylingFlags, StylingIndex} from '../interfaces/styling';\nimport {LView, RootContext} from '../interfaces/view';\nimport {NO_CHANGE} from '../tokens';\nimport {getRootContext} from '../util';\n\nimport {BoundPlayerFactory} from './player_factory';\nimport {addPlayerInternal, allocPlayerContext, createEmptyStylingContext, getPlayerContext} from './util';\n\nconst EMPTY_ARR: any[] = [];\nconst EMPTY_OBJ: {[key: string]: any} = {};\n\n\n/**\n * Creates a styling context template where styling information is stored.\n * Any styles that are later referenced using `updateStyleProp` must be\n * passed in within this function. Initial values for those styles are to\n * be declared after all initial style properties are declared (this change in\n * mode between declarations and initial styles is made possible using a special\n * enum value found in `definition.ts`).\n *\n * @param initialStyleDeclarations a list of style declarations and initial style values\n *    that are used later within the styling context.\n *\n *    -> ['width', 'height', SPECIAL_ENUM_VAL, 'width', '100px']\n *       This implies that `width` and `height` will be later styled and that the `width`\n *       property has an initial value of `100px`.\n *\n * @param initialClassDeclarations a list of class declarations and initial class values\n *    that are used later within the styling context.\n *\n *    -> ['foo', 'bar', SPECIAL_ENUM_VAL, 'foo', true]\n *       This implies that `foo` and `bar` will be later styled and that the `foo`\n *       class will be applied to the element as an initial class since it's true\n */\nexport function createStylingContextTemplate(\n    initialClassDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    initialStyleDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    styleSanitizer?: StyleSanitizeFn | null, onlyProcessSingleClasses?: boolean): StylingContext {\n  const initialStylingValues: InitialStyles = [null];\n  const context: StylingContext =\n      createEmptyStylingContext(null, styleSanitizer, initialStylingValues);\n\n  // we use two maps since a class name might collide with a CSS style prop\n  const stylesLookup: {[key: string]: number} = {};\n  const classesLookup: {[key: string]: number} = {};\n\n  let totalStyleDeclarations = 0;\n  if (initialStyleDeclarations) {\n    let hasPassedDeclarations = false;\n    for (let i = 0; i < initialStyleDeclarations.length; i++) {\n      const v = initialStyleDeclarations[i] as string | InitialStylingFlags;\n\n      // this flag value marks where the declarations end the initial values begin\n      if (v === InitialStylingFlags.VALUES_MODE) {\n        hasPassedDeclarations = true;\n      } else {\n        const prop = v as string;\n        if (hasPassedDeclarations) {\n          const value = initialStyleDeclarations[++i] as string;\n          initialStylingValues.push(value);\n          stylesLookup[prop] = initialStylingValues.length - 1;\n        } else {\n          totalStyleDeclarations++;\n          stylesLookup[prop] = 0;\n        }\n      }\n    }\n  }\n\n  // make where the class offsets begin\n  context[StylingIndex.ClassOffsetPosition] = totalStyleDeclarations;\n\n  const initialStaticClasses: string[]|null = onlyProcessSingleClasses ? [] : null;\n  if (initialClassDeclarations) {\n    let hasPassedDeclarations = false;\n    for (let i = 0; i < initialClassDeclarations.length; i++) {\n      const v = initialClassDeclarations[i] as string | boolean | InitialStylingFlags;\n      // this flag value marks where the declarations end the initial values begin\n      if (v === InitialStylingFlags.VALUES_MODE) {\n        hasPassedDeclarations = true;\n      } else {\n        const className = v as string;\n        if (hasPassedDeclarations) {\n          const value = initialClassDeclarations[++i] as boolean;\n          initialStylingValues.push(value);\n          classesLookup[className] = initialStylingValues.length - 1;\n          initialStaticClasses && initialStaticClasses.push(className);\n        } else {\n          classesLookup[className] = 0;\n        }\n      }\n    }\n  }\n\n  const styleProps = Object.keys(stylesLookup);\n  const classNames = Object.keys(classesLookup);\n  const classNamesIndexStart = styleProps.length;\n  const totalProps = styleProps.length + classNames.length;\n\n  // *2 because we are filling for both single and multi style spaces\n  const maxLength = totalProps * StylingIndex.Size * 2 + StylingIndex.SingleStylesStartPosition;\n\n  // we need to fill the array from the start so that we can access\n  // both the multi and the single array positions in the same loop block\n  for (let i = StylingIndex.SingleStylesStartPosition; i < maxLength; i++) {\n    context.push(null);\n  }\n\n  const singleStart = StylingIndex.SingleStylesStartPosition;\n  const multiStart = totalProps * StylingIndex.Size + StylingIndex.SingleStylesStartPosition;\n\n  // fill single and multi-level styles\n  for (let i = 0; i < totalProps; i++) {\n    const isClassBased = i >= classNamesIndexStart;\n    const prop = isClassBased ? classNames[i - classNamesIndexStart] : styleProps[i];\n    const indexForInitial = isClassBased ? classesLookup[prop] : stylesLookup[prop];\n    const initialValue = initialStylingValues[indexForInitial];\n\n    const indexForMulti = i * StylingIndex.Size + multiStart;\n    const indexForSingle = i * StylingIndex.Size + singleStart;\n    const initialFlag = prepareInitialFlag(prop, isClassBased, styleSanitizer || null);\n\n    setFlag(context, indexForSingle, pointers(initialFlag, indexForInitial, indexForMulti));\n    setProp(context, indexForSingle, prop);\n    setValue(context, indexForSingle, null);\n    setPlayerBuilderIndex(context, indexForSingle, 0);\n\n    const flagForMulti =\n        initialFlag | (initialValue !== null ? StylingFlags.Dirty : StylingFlags.None);\n    setFlag(context, indexForMulti, pointers(flagForMulti, indexForInitial, indexForSingle));\n    setProp(context, indexForMulti, prop);\n    setValue(context, indexForMulti, null);\n    setPlayerBuilderIndex(context, indexForMulti, 0);\n  }\n\n  // there is no initial value flag for the master index since it doesn't\n  // reference an initial style value\n  const masterFlag = pointers(0, 0, multiStart) |\n      (onlyProcessSingleClasses ? StylingFlags.OnlyProcessSingleClasses : 0);\n  setFlag(context, StylingIndex.MasterFlagPosition, masterFlag);\n  setContextDirty(context, initialStylingValues.length > 1);\n\n  if (initialStaticClasses) {\n    context[StylingIndex.PreviousOrCachedMultiClassValue] = initialStaticClasses.join(' ');\n  }\n\n  return context;\n}\n\n/**\n * Sets and resolves all `multi` styling on an `StylingContext` so that they can be\n * applied to the element once `renderStyleAndClassBindings` is called.\n *\n * All missing styles/class (any values that are not provided in the new `styles`\n * or `classes` params) will resolve to `null` within their respective positions\n * in the context.\n *\n * @param context The styling context that will be updated with the\n *    newly provided style values.\n * @param classesInput The key/value map of CSS class names that will be used for the update.\n * @param stylesInput The key/value map of CSS styles that will be used for the update.\n */\nexport function updateStylingMap(\n    context: StylingContext, classesInput: {[key: string]: any} | string |\n        BoundPlayerFactory<null|string|{[key: string]: any}>| NO_CHANGE | null,\n    stylesInput?: {[key: string]: any} | BoundPlayerFactory<null|{[key: string]: any}>| NO_CHANGE |\n        null): void {\n  stylesInput = stylesInput || null;\n\n  const element = context[StylingIndex.ElementPosition] !as HTMLElement;\n  const classesPlayerBuilder = classesInput instanceof BoundPlayerFactory ?\n      new ClassAndStylePlayerBuilder(classesInput as any, element, BindingType.Class) :\n      null;\n  const stylesPlayerBuilder = stylesInput instanceof BoundPlayerFactory ?\n      new ClassAndStylePlayerBuilder(stylesInput as any, element, BindingType.Style) :\n      null;\n\n  const classesValue = classesPlayerBuilder ?\n      (classesInput as BoundPlayerFactory<{[key: string]: any}|string>) !.value :\n      classesInput;\n  const stylesValue = stylesPlayerBuilder ? stylesInput !.value : stylesInput;\n  // early exit (this is what's done to avoid using ctx.bind() to cache the value)\n  const ignoreAllClassUpdates = limitToSingleClasses(context) || classesValue === NO_CHANGE ||\n      classesValue === context[StylingIndex.PreviousOrCachedMultiClassValue];\n  const ignoreAllStyleUpdates =\n      stylesValue === NO_CHANGE || stylesValue === context[StylingIndex.PreviousMultiStyleValue];\n  if (ignoreAllClassUpdates && ignoreAllStyleUpdates) return;\n\n  context[StylingIndex.PreviousOrCachedMultiClassValue] = classesValue;\n  context[StylingIndex.PreviousMultiStyleValue] = stylesValue;\n\n  let classNames: string[] = EMPTY_ARR;\n  let applyAllClasses = false;\n  let playerBuildersAreDirty = false;\n\n  const classesPlayerBuilderIndex =\n      classesPlayerBuilder ? PlayerIndex.ClassMapPlayerBuilderPosition : 0;\n  if (hasPlayerBuilderChanged(\n          context, classesPlayerBuilder, PlayerIndex.ClassMapPlayerBuilderPosition)) {\n    setPlayerBuilder(context, classesPlayerBuilder, PlayerIndex.ClassMapPlayerBuilderPosition);\n    playerBuildersAreDirty = true;\n  }\n\n  const stylesPlayerBuilderIndex =\n      stylesPlayerBuilder ? PlayerIndex.StyleMapPlayerBuilderPosition : 0;\n  if (hasPlayerBuilderChanged(\n          context, stylesPlayerBuilder, PlayerIndex.StyleMapPlayerBuilderPosition)) {\n    setPlayerBuilder(context, stylesPlayerBuilder, PlayerIndex.StyleMapPlayerBuilderPosition);\n    playerBuildersAreDirty = true;\n  }\n\n  // each time a string-based value pops up then it shouldn't require a deep\n  // check of what's changed.\n  if (!ignoreAllClassUpdates) {\n    if (typeof classesValue == 'string') {\n      classNames = classesValue.split(/\\s+/);\n      // this boolean is used to avoid having to create a key/value map of `true` values\n      // since a classname string implies that all those classes are added\n      applyAllClasses = true;\n    } else {\n      classNames = classesValue ? Object.keys(classesValue) : EMPTY_ARR;\n    }\n  }\n\n  const classes = (classesValue || EMPTY_OBJ) as{[key: string]: any};\n  const styleProps = stylesValue ? Object.keys(stylesValue) : EMPTY_ARR;\n  const styles = stylesValue || EMPTY_OBJ;\n\n  const classesStartIndex = styleProps.length;\n  const multiStartIndex = getMultiStartIndex(context);\n\n  let dirty = false;\n  let ctxIndex = multiStartIndex;\n\n  let propIndex = 0;\n  const propLimit = styleProps.length + classNames.length;\n\n  // the main loop here will try and figure out how the shape of the provided\n  // styles differ with respect to the context. Later if the context/styles/classes\n  // are off-balance then they will be dealt in another loop after this one\n  while (ctxIndex < context.length && propIndex < propLimit) {\n    const isClassBased = propIndex >= classesStartIndex;\n    const processValue =\n        (!isClassBased && !ignoreAllStyleUpdates) || (isClassBased && !ignoreAllClassUpdates);\n\n    // when there is a cache-hit for a string-based class then we should\n    // avoid doing any work diffing any of the changes\n    if (processValue) {\n      const adjustedPropIndex = isClassBased ? propIndex - classesStartIndex : propIndex;\n      const newProp: string =\n          isClassBased ? classNames[adjustedPropIndex] : styleProps[adjustedPropIndex];\n      const newValue: string|boolean =\n          isClassBased ? (applyAllClasses ? true : classes[newProp]) : styles[newProp];\n      const playerBuilderIndex =\n          isClassBased ? classesPlayerBuilderIndex : stylesPlayerBuilderIndex;\n\n      const prop = getProp(context, ctxIndex);\n      if (prop === newProp) {\n        const value = getValue(context, ctxIndex);\n        const flag = getPointers(context, ctxIndex);\n        setPlayerBuilderIndex(context, ctxIndex, playerBuilderIndex);\n\n        if (hasValueChanged(flag, value, newValue)) {\n          setValue(context, ctxIndex, newValue);\n          playerBuildersAreDirty = playerBuildersAreDirty || !!playerBuilderIndex;\n\n          const initialValue = getInitialValue(context, flag);\n\n          // there is no point in setting this to dirty if the previously\n          // rendered value was being referenced by the initial style (or null)\n          if (hasValueChanged(flag, initialValue, newValue)) {\n            setDirty(context, ctxIndex, true);\n            dirty = true;\n          }\n        }\n      } else {\n        const indexOfEntry = findEntryPositionByProp(context, newProp, ctxIndex);\n        if (indexOfEntry > 0) {\n          // it was found at a later point ... just swap the values\n          const valueToCompare = getValue(context, indexOfEntry);\n          const flagToCompare = getPointers(context, indexOfEntry);\n          swapMultiContextEntries(context, ctxIndex, indexOfEntry);\n          if (hasValueChanged(flagToCompare, valueToCompare, newValue)) {\n            const initialValue = getInitialValue(context, flagToCompare);\n            setValue(context, ctxIndex, newValue);\n            if (hasValueChanged(flagToCompare, initialValue, newValue)) {\n              setDirty(context, ctxIndex, true);\n              playerBuildersAreDirty = playerBuildersAreDirty || !!playerBuilderIndex;\n              dirty = true;\n            }\n          }\n        } else {\n          // we only care to do this if the insertion is in the middle\n          const newFlag = prepareInitialFlag(newProp, isClassBased, getStyleSanitizer(context));\n          playerBuildersAreDirty = playerBuildersAreDirty || !!playerBuilderIndex;\n          insertNewMultiProperty(\n              context, ctxIndex, isClassBased, newProp, newFlag, newValue, playerBuilderIndex);\n          dirty = true;\n        }\n      }\n    }\n\n    ctxIndex += StylingIndex.Size;\n    propIndex++;\n  }\n\n  // this means that there are left-over values in the context that\n  // were not included in the provided styles/classes and in this\n  // case the  goal is to \"remove\" them from the context (by nullifying)\n  while (ctxIndex < context.length) {\n    const flag = getPointers(context, ctxIndex);\n    const isClassBased = (flag & StylingFlags.Class) === StylingFlags.Class;\n    const processValue =\n        (!isClassBased && !ignoreAllStyleUpdates) || (isClassBased && !ignoreAllClassUpdates);\n    if (processValue) {\n      const value = getValue(context, ctxIndex);\n      const doRemoveValue = valueExists(value, isClassBased);\n      if (doRemoveValue) {\n        setDirty(context, ctxIndex, true);\n        setValue(context, ctxIndex, null);\n\n        // we keep the player factory the same so that the `nulled` value can\n        // be instructed into the player because removing a style and/or a class\n        // is a valid animation player instruction.\n        const playerBuilderIndex =\n            isClassBased ? classesPlayerBuilderIndex : stylesPlayerBuilderIndex;\n        setPlayerBuilderIndex(context, ctxIndex, playerBuilderIndex);\n        dirty = true;\n      }\n    }\n    ctxIndex += StylingIndex.Size;\n  }\n\n  // this means that there are left-over properties in the context that\n  // were not detected in the context during the loop above. In that\n  // case we want to add the new entries into the list\n  const sanitizer = getStyleSanitizer(context);\n  while (propIndex < propLimit) {\n    const isClassBased = propIndex >= classesStartIndex;\n    const processValue =\n        (!isClassBased && !ignoreAllStyleUpdates) || (isClassBased && !ignoreAllClassUpdates);\n    if (processValue) {\n      const adjustedPropIndex = isClassBased ? propIndex - classesStartIndex : propIndex;\n      const prop = isClassBased ? classNames[adjustedPropIndex] : styleProps[adjustedPropIndex];\n      const value: string|boolean =\n          isClassBased ? (applyAllClasses ? true : classes[prop]) : styles[prop];\n      const flag = prepareInitialFlag(prop, isClassBased, sanitizer) | StylingFlags.Dirty;\n      const playerBuilderIndex =\n          isClassBased ? classesPlayerBuilderIndex : stylesPlayerBuilderIndex;\n      context.push(flag, prop, value, playerBuilderIndex);\n      dirty = true;\n    }\n    propIndex++;\n  }\n\n  if (dirty) {\n    setContextDirty(context, true);\n  }\n\n  if (playerBuildersAreDirty) {\n    setContextPlayersDirty(context, true);\n  }\n}\n\n/**\n * Sets and resolves a single styling property/value on the provided `StylingContext` so\n * that they can be applied to the element once `renderStyleAndClassBindings` is called.\n *\n * Note that prop-level styling values are considered higher priority than any styling that\n * has been applied using `updateStylingMap`, therefore, when styling values are rendered\n * then any styles/classes that have been applied using this function will be considered first\n * (then multi values second and then initial values as a backup).\n *\n * @param context The styling context that will be updated with the\n *    newly provided style value.\n * @param index The index of the property which is being updated.\n * @param value The CSS style value that will be assigned\n */\nexport function updateStyleProp(\n    context: StylingContext, index: number,\n    input: string | boolean | null | BoundPlayerFactory<string|boolean|null>): void {\n  const singleIndex = StylingIndex.SingleStylesStartPosition + index * StylingIndex.Size;\n  const currValue = getValue(context, singleIndex);\n  const currFlag = getPointers(context, singleIndex);\n  const value: string|boolean|null = (input instanceof BoundPlayerFactory) ? input.value : input;\n\n  // didn't change ... nothing to make a note of\n  if (hasValueChanged(currFlag, currValue, value)) {\n    const isClassBased = (currFlag & StylingFlags.Class) === StylingFlags.Class;\n    const element = context[StylingIndex.ElementPosition] !as HTMLElement;\n    const playerBuilder = input instanceof BoundPlayerFactory ?\n        new ClassAndStylePlayerBuilder(\n            input as any, element, isClassBased ? BindingType.Class : BindingType.Style) :\n        null;\n    const value = (playerBuilder ? (input as BoundPlayerFactory<any>).value : input) as string |\n        boolean | null;\n    const currPlayerIndex = getPlayerBuilderIndex(context, singleIndex);\n\n    let playerBuildersAreDirty = false;\n    let playerBuilderIndex = playerBuilder ? currPlayerIndex : 0;\n    if (hasPlayerBuilderChanged(context, playerBuilder, currPlayerIndex)) {\n      const newIndex = setPlayerBuilder(context, playerBuilder, currPlayerIndex);\n      playerBuilderIndex = playerBuilder ? newIndex : 0;\n      setPlayerBuilderIndex(context, singleIndex, playerBuilderIndex);\n      playerBuildersAreDirty = true;\n    }\n\n    // the value will always get updated (even if the dirty flag is skipped)\n    setValue(context, singleIndex, value);\n    const indexForMulti = getMultiOrSingleIndex(currFlag);\n\n    // if the value is the same in the multi-area then there's no point in re-assembling\n    const valueForMulti = getValue(context, indexForMulti);\n    if (!valueForMulti || hasValueChanged(currFlag, valueForMulti, value)) {\n      let multiDirty = false;\n      let singleDirty = true;\n\n      // only when the value is set to `null` should the multi-value get flagged\n      if (!valueExists(value, isClassBased) && valueExists(valueForMulti, isClassBased)) {\n        multiDirty = true;\n        singleDirty = false;\n      }\n\n      setDirty(context, indexForMulti, multiDirty);\n      setDirty(context, singleIndex, singleDirty);\n      setContextDirty(context, true);\n    }\n\n    if (playerBuildersAreDirty) {\n      setContextPlayersDirty(context, true);\n    }\n  }\n}\n\n/**\n * This method will toggle the referenced CSS class (by the provided index)\n * within the given context.\n *\n * @param context The styling context that will be updated with the\n *    newly provided class value.\n * @param index The index of the CSS class which is being updated.\n * @param addOrRemove Whether or not to add or remove the CSS class\n */\nexport function updateClassProp(\n    context: StylingContext, index: number,\n    addOrRemove: boolean | BoundPlayerFactory<boolean>): void {\n  const adjustedIndex = index + context[StylingIndex.ClassOffsetPosition];\n  updateStyleProp(context, adjustedIndex, addOrRemove);\n}\n\n/**\n * Renders all queued styling using a renderer onto the given element.\n *\n * This function works by rendering any styles (that have been applied\n * using `updateStylingMap`) and any classes (that have been applied using\n * `updateStyleProp`) onto the provided element using the provided renderer.\n * Just before the styles/classes are rendered a final key/value style map\n * will be assembled (if `styleStore` or `classStore` are provided).\n *\n * @param lElement the element that the styles will be rendered on\n * @param context The styling context that will be used to determine\n *      what styles will be rendered\n * @param renderer the renderer that will be used to apply the styling\n * @param classesStore if provided, the updated class values will be applied\n *    to this key/value map instead of being renderered via the renderer.\n * @param stylesStore if provided, the updated style values will be applied\n *    to this key/value map instead of being renderered via the renderer.\n * @returns number the total amount of players that got queued for animation (if any)\n */\nexport function renderStyleAndClassBindings(\n    context: StylingContext, renderer: Renderer3, rootOrView: RootContext | LView,\n    isFirstRender: boolean, classesStore?: BindingStore | null,\n    stylesStore?: BindingStore | null): number {\n  let totalPlayersQueued = 0;\n\n  if (isContextDirty(context)) {\n    const flushPlayerBuilders: any =\n        context[StylingIndex.MasterFlagPosition] & StylingFlags.PlayerBuildersDirty;\n    const native = context[StylingIndex.ElementPosition] !;\n    const multiStartIndex = getMultiStartIndex(context);\n    const styleSanitizer = getStyleSanitizer(context);\n    const onlySingleClasses = limitToSingleClasses(context);\n\n    for (let i = StylingIndex.SingleStylesStartPosition; i < context.length;\n         i += StylingIndex.Size) {\n      // there is no point in rendering styles that have not changed on screen\n      if (isDirty(context, i)) {\n        const prop = getProp(context, i);\n        const value = getValue(context, i);\n        const flag = getPointers(context, i);\n        const playerBuilder = getPlayerBuilder(context, i);\n        const isClassBased = flag & StylingFlags.Class ? true : false;\n        const isInSingleRegion = i < multiStartIndex;\n        const readInitialValue = !isClassBased || !onlySingleClasses;\n\n        let valueToApply: string|boolean|null = value;\n\n        // VALUE DEFER CASE 1: Use a multi value instead of a null single value\n        // this check implies that a single value was removed and we\n        // should now defer to a multi value and use that (if set).\n        if (isInSingleRegion && !valueExists(valueToApply, isClassBased)) {\n          // single values ALWAYS have a reference to a multi index\n          const multiIndex = getMultiOrSingleIndex(flag);\n          valueToApply = getValue(context, multiIndex);\n        }\n\n        // VALUE DEFER CASE 2: Use the initial value if all else fails (is falsy)\n        // the initial value will always be a string or null,\n        // therefore we can safely adopt it incase there's nothing else\n        // note that this should always be a falsy check since `false` is used\n        // for both class and style comparisons (styles can't be false and false\n        // classes are turned off and should therefore defer to their initial values)\n        if (!valueExists(valueToApply, isClassBased) && readInitialValue) {\n          valueToApply = getInitialValue(context, flag);\n        }\n\n        // if the first render is true then we do not want to start applying falsy\n        // values to the DOM element's styling. Otherwise then we know there has\n        // been a change and even if it's falsy then it's removing something that\n        // was truthy before.\n        const doApplyValue = isFirstRender ? valueToApply : true;\n        if (doApplyValue) {\n          if (isClassBased) {\n            setClass(\n                native, prop, valueToApply ? true : false, renderer, classesStore, playerBuilder);\n          } else {\n            const sanitizer = (flag & StylingFlags.Sanitize) ? styleSanitizer : null;\n            setStyle(\n                native, prop, valueToApply as string | null, renderer, sanitizer, stylesStore,\n                playerBuilder);\n          }\n        }\n\n        setDirty(context, i, false);\n      }\n    }\n\n    if (flushPlayerBuilders) {\n      const rootContext =\n          Array.isArray(rootOrView) ? getRootContext(rootOrView) : rootOrView as RootContext;\n      const playerContext = getPlayerContext(context) !;\n      const playersStartIndex = playerContext[PlayerIndex.NonBuilderPlayersStart];\n      for (let i = PlayerIndex.PlayerBuildersStartPosition; i < playersStartIndex;\n           i += PlayerIndex.PlayerAndPlayerBuildersTupleSize) {\n        const builder = playerContext[i] as ClassAndStylePlayerBuilder<any>| null;\n        const playerInsertionIndex = i + PlayerIndex.PlayerOffsetPosition;\n        const oldPlayer = playerContext[playerInsertionIndex] as Player | null;\n        if (builder) {\n          const player = builder.buildPlayer(oldPlayer, isFirstRender);\n          if (player !== undefined) {\n            if (player != null) {\n              const wasQueued = addPlayerInternal(\n                  playerContext, rootContext, native as HTMLElement, player, playerInsertionIndex);\n              wasQueued && totalPlayersQueued++;\n            }\n            if (oldPlayer) {\n              oldPlayer.destroy();\n            }\n          }\n        } else if (oldPlayer) {\n          // the player builder has been removed ... therefore we should delete the associated\n          // player\n          oldPlayer.destroy();\n        }\n      }\n      setContextPlayersDirty(context, false);\n    }\n    setContextDirty(context, false);\n  }\n\n  return totalPlayersQueued;\n}\n\n/**\n * This function renders a given CSS prop/value entry using the\n * provided renderer. If a `store` value is provided then\n * that will be used a render context instead of the provided\n * renderer.\n *\n * @param native the DOM Element\n * @param prop the CSS style property that will be rendered\n * @param value the CSS style value that will be rendered\n * @param renderer\n * @param store an optional key/value map that will be used as a context to render styles on\n */\nfunction setStyle(\n    native: any, prop: string, value: string | null, renderer: Renderer3,\n    sanitizer: StyleSanitizeFn | null, store?: BindingStore | null,\n    playerBuilder?: ClassAndStylePlayerBuilder<any>| null) {\n  value = sanitizer && value ? sanitizer(prop, value) : value;\n  if (store || playerBuilder) {\n    if (store) {\n      store.setValue(prop, value);\n    }\n    if (playerBuilder) {\n      playerBuilder.setValue(prop, value);\n    }\n  } else if (value) {\n    ngDevMode && ngDevMode.rendererSetStyle++;\n    isProceduralRenderer(renderer) ?\n        renderer.setStyle(native, prop, value, RendererStyleFlags3.DashCase) :\n        native['style'].setProperty(prop, value);\n  } else {\n    ngDevMode && ngDevMode.rendererRemoveStyle++;\n    isProceduralRenderer(renderer) ?\n        renderer.removeStyle(native, prop, RendererStyleFlags3.DashCase) :\n        native['style'].removeProperty(prop);\n  }\n}\n\n/**\n * This function renders a given CSS class value using the provided\n * renderer (by adding or removing it from the provided element).\n * If a `store` value is provided then that will be used a render\n * context instead of the provided renderer.\n *\n * @param native the DOM Element\n * @param prop the CSS style property that will be rendered\n * @param value the CSS style value that will be rendered\n * @param renderer\n * @param store an optional key/value map that will be used as a context to render styles on\n */\nfunction setClass(\n    native: any, className: string, add: boolean, renderer: Renderer3, store?: BindingStore | null,\n    playerBuilder?: ClassAndStylePlayerBuilder<any>| null) {\n  if (store || playerBuilder) {\n    if (store) {\n      store.setValue(className, add);\n    }\n    if (playerBuilder) {\n      playerBuilder.setValue(className, add);\n    }\n  } else if (add) {\n    ngDevMode && ngDevMode.rendererAddClass++;\n    isProceduralRenderer(renderer) ? renderer.addClass(native, className) :\n                                     native['classList'].add(className);\n  } else {\n    ngDevMode && ngDevMode.rendererRemoveClass++;\n    isProceduralRenderer(renderer) ? renderer.removeClass(native, className) :\n                                     native['classList'].remove(className);\n  }\n}\n\nfunction setDirty(context: StylingContext, index: number, isDirtyYes: boolean) {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  if (isDirtyYes) {\n    (context[adjustedIndex] as number) |= StylingFlags.Dirty;\n  } else {\n    (context[adjustedIndex] as number) &= ~StylingFlags.Dirty;\n  }\n}\n\nfunction isDirty(context: StylingContext, index: number): boolean {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  return ((context[adjustedIndex] as number) & StylingFlags.Dirty) == StylingFlags.Dirty;\n}\n\nfunction isClassBased(context: StylingContext, index: number): boolean {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  return ((context[adjustedIndex] as number) & StylingFlags.Class) == StylingFlags.Class;\n}\n\nfunction isSanitizable(context: StylingContext, index: number): boolean {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  return ((context[adjustedIndex] as number) & StylingFlags.Sanitize) == StylingFlags.Sanitize;\n}\n\nfunction pointers(configFlag: number, staticIndex: number, dynamicIndex: number) {\n  return (configFlag & StylingFlags.BitMask) | (staticIndex << StylingFlags.BitCountSize) |\n      (dynamicIndex << (StylingIndex.BitCountSize + StylingFlags.BitCountSize));\n}\n\nfunction getInitialValue(context: StylingContext, flag: number): string|null {\n  const index = getInitialIndex(flag);\n  return context[StylingIndex.InitialStylesPosition][index] as null | string;\n}\n\nfunction getInitialIndex(flag: number): number {\n  return (flag >> StylingFlags.BitCountSize) & StylingIndex.BitMask;\n}\n\nfunction getMultiOrSingleIndex(flag: number): number {\n  const index =\n      (flag >> (StylingIndex.BitCountSize + StylingFlags.BitCountSize)) & StylingIndex.BitMask;\n  return index >= StylingIndex.SingleStylesStartPosition ? index : -1;\n}\n\nfunction getMultiStartIndex(context: StylingContext): number {\n  return getMultiOrSingleIndex(context[StylingIndex.MasterFlagPosition]) as number;\n}\n\nfunction getStyleSanitizer(context: StylingContext): StyleSanitizeFn|null {\n  return context[StylingIndex.StyleSanitizerPosition];\n}\n\nfunction setProp(context: StylingContext, index: number, prop: string) {\n  context[index + StylingIndex.PropertyOffset] = prop;\n}\n\nfunction setValue(context: StylingContext, index: number, value: string | null | boolean) {\n  context[index + StylingIndex.ValueOffset] = value;\n}\n\nfunction hasPlayerBuilderChanged(\n    context: StylingContext, builder: ClassAndStylePlayerBuilder<any>| null, index: number) {\n  const playerContext = context[StylingIndex.PlayerContext] !;\n  if (builder) {\n    if (!playerContext || index === 0) {\n      return true;\n    }\n  } else if (!playerContext) {\n    return false;\n  }\n  return playerContext[index] !== builder;\n}\n\nfunction setPlayerBuilder(\n    context: StylingContext, builder: ClassAndStylePlayerBuilder<any>| null,\n    insertionIndex: number): number {\n  let playerContext = context[StylingIndex.PlayerContext] || allocPlayerContext(context);\n  if (insertionIndex > 0) {\n    playerContext[insertionIndex] = builder;\n  } else {\n    insertionIndex = playerContext[PlayerIndex.NonBuilderPlayersStart];\n    playerContext.splice(insertionIndex, 0, builder, null);\n    playerContext[PlayerIndex.NonBuilderPlayersStart] +=\n        PlayerIndex.PlayerAndPlayerBuildersTupleSize;\n  }\n  return insertionIndex;\n}\n\nfunction setPlayerBuilderIndex(context: StylingContext, index: number, playerBuilderIndex: number) {\n  context[index + StylingIndex.PlayerBuilderIndexOffset] = playerBuilderIndex;\n}\n\nfunction getPlayerBuilderIndex(context: StylingContext, index: number): number {\n  return (context[index + StylingIndex.PlayerBuilderIndexOffset] as number) || 0;\n}\n\nfunction getPlayerBuilder(context: StylingContext, index: number): ClassAndStylePlayerBuilder<any>|\n    null {\n  const playerBuilderIndex = getPlayerBuilderIndex(context, index);\n  if (playerBuilderIndex) {\n    const playerContext = context[StylingIndex.PlayerContext];\n    if (playerContext) {\n      return playerContext[playerBuilderIndex] as ClassAndStylePlayerBuilder<any>| null;\n    }\n  }\n  return null;\n}\n\nfunction setFlag(context: StylingContext, index: number, flag: number) {\n  const adjustedIndex =\n      index === StylingIndex.MasterFlagPosition ? index : (index + StylingIndex.FlagsOffset);\n  context[adjustedIndex] = flag;\n}\n\nfunction getPointers(context: StylingContext, index: number): number {\n  const adjustedIndex =\n      index === StylingIndex.MasterFlagPosition ? index : (index + StylingIndex.FlagsOffset);\n  return context[adjustedIndex] as number;\n}\n\nfunction getValue(context: StylingContext, index: number): string|boolean|null {\n  return context[index + StylingIndex.ValueOffset] as string | boolean | null;\n}\n\nfunction getProp(context: StylingContext, index: number): string {\n  return context[index + StylingIndex.PropertyOffset] as string;\n}\n\nexport function isContextDirty(context: StylingContext): boolean {\n  return isDirty(context, StylingIndex.MasterFlagPosition);\n}\n\nexport function limitToSingleClasses(context: StylingContext) {\n  return context[StylingIndex.MasterFlagPosition] & StylingFlags.OnlyProcessSingleClasses;\n}\n\nexport function setContextDirty(context: StylingContext, isDirtyYes: boolean): void {\n  setDirty(context, StylingIndex.MasterFlagPosition, isDirtyYes);\n}\n\nexport function setContextPlayersDirty(context: StylingContext, isDirtyYes: boolean): void {\n  if (isDirtyYes) {\n    (context[StylingIndex.MasterFlagPosition] as number) |= StylingFlags.PlayerBuildersDirty;\n  } else {\n    (context[StylingIndex.MasterFlagPosition] as number) &= ~StylingFlags.PlayerBuildersDirty;\n  }\n}\n\nfunction findEntryPositionByProp(\n    context: StylingContext, prop: string, startIndex?: number): number {\n  for (let i = (startIndex || 0) + StylingIndex.PropertyOffset; i < context.length;\n       i += StylingIndex.Size) {\n    const thisProp = context[i];\n    if (thisProp == prop) {\n      return i - StylingIndex.PropertyOffset;\n    }\n  }\n  return -1;\n}\n\nfunction swapMultiContextEntries(context: StylingContext, indexA: number, indexB: number) {\n  const tmpValue = getValue(context, indexA);\n  const tmpProp = getProp(context, indexA);\n  const tmpFlag = getPointers(context, indexA);\n  const tmpPlayerBuilderIndex = getPlayerBuilderIndex(context, indexA);\n\n  let flagA = tmpFlag;\n  let flagB = getPointers(context, indexB);\n\n  const singleIndexA = getMultiOrSingleIndex(flagA);\n  if (singleIndexA >= 0) {\n    const _flag = getPointers(context, singleIndexA);\n    const _initial = getInitialIndex(_flag);\n    setFlag(context, singleIndexA, pointers(_flag, _initial, indexB));\n  }\n\n  const singleIndexB = getMultiOrSingleIndex(flagB);\n  if (singleIndexB >= 0) {\n    const _flag = getPointers(context, singleIndexB);\n    const _initial = getInitialIndex(_flag);\n    setFlag(context, singleIndexB, pointers(_flag, _initial, indexA));\n  }\n\n  setValue(context, indexA, getValue(context, indexB));\n  setProp(context, indexA, getProp(context, indexB));\n  setFlag(context, indexA, getPointers(context, indexB));\n  setPlayerBuilderIndex(context, indexA, getPlayerBuilderIndex(context, indexB));\n\n  setValue(context, indexB, tmpValue);\n  setProp(context, indexB, tmpProp);\n  setFlag(context, indexB, tmpFlag);\n  setPlayerBuilderIndex(context, indexB, tmpPlayerBuilderIndex);\n}\n\nfunction updateSinglePointerValues(context: StylingContext, indexStartPosition: number) {\n  for (let i = indexStartPosition; i < context.length; i += StylingIndex.Size) {\n    const multiFlag = getPointers(context, i);\n    const singleIndex = getMultiOrSingleIndex(multiFlag);\n    if (singleIndex > 0) {\n      const singleFlag = getPointers(context, singleIndex);\n      const initialIndexForSingle = getInitialIndex(singleFlag);\n      const flagValue = (isDirty(context, singleIndex) ? StylingFlags.Dirty : StylingFlags.None) |\n          (isClassBased(context, singleIndex) ? StylingFlags.Class : StylingFlags.None) |\n          (isSanitizable(context, singleIndex) ? StylingFlags.Sanitize : StylingFlags.None);\n      const updatedFlag = pointers(flagValue, initialIndexForSingle, i);\n      setFlag(context, singleIndex, updatedFlag);\n    }\n  }\n}\n\nfunction insertNewMultiProperty(\n    context: StylingContext, index: number, classBased: boolean, name: string, flag: number,\n    value: string | boolean, playerIndex: number): void {\n  const doShift = index < context.length;\n\n  // prop does not exist in the list, add it in\n  context.splice(\n      index, 0, flag | StylingFlags.Dirty | (classBased ? StylingFlags.Class : StylingFlags.None),\n      name, value, playerIndex);\n\n  if (doShift) {\n    // because the value was inserted midway into the array then we\n    // need to update all the shifted multi values' single value\n    // pointers to point to the newly shifted location\n    updateSinglePointerValues(context, index + StylingIndex.Size);\n  }\n}\n\nfunction valueExists(value: string | null | boolean, isClassBased?: boolean) {\n  if (isClassBased) {\n    return value ? true : false;\n  }\n  return value !== null;\n}\n\nfunction prepareInitialFlag(\n    name: string, isClassBased: boolean, sanitizer?: StyleSanitizeFn | null) {\n  if (isClassBased) {\n    return StylingFlags.Class;\n  } else if (sanitizer && sanitizer(name)) {\n    return StylingFlags.Sanitize;\n  }\n  return StylingFlags.None;\n}\n\nfunction hasValueChanged(\n    flag: number, a: string | boolean | null, b: string | boolean | null): boolean {\n  const isClassBased = flag & StylingFlags.Class;\n  const hasValues = a && b;\n  const usesSanitizer = flag & StylingFlags.Sanitize;\n  // the toString() comparison ensures that a value is checked\n  // ... otherwise (during sanitization bypassing) the === comparsion\n  // would fail since a new String() instance is created\n  if (!isClassBased && hasValues && usesSanitizer) {\n    // we know for sure we're dealing with strings at this point\n    return (a as string).toString() !== (b as string).toString();\n  }\n\n  // everything else is safe to check with a normal equality check\n  return a !== b;\n}\n\nexport class ClassAndStylePlayerBuilder<T> implements PlayerBuilder {\n  private _values: {[key: string]: string | null} = {};\n  private _dirty = false;\n  private _factory: BoundPlayerFactory<T>;\n\n  constructor(factory: PlayerFactory, private _element: HTMLElement, private _type: BindingType) {\n    this._factory = factory as any;\n  }\n\n  setValue(prop: string, value: any) {\n    if (this._values[prop] !== value) {\n      this._values[prop] = value;\n      this._dirty = true;\n    }\n  }\n\n  buildPlayer(currentPlayer: Player|null, isFirstRender: boolean): Player|undefined|null {\n    // if no values have been set here then this means the binding didn't\n    // change and therefore the binding values were not updated through\n    // `setValue` which means no new player will be provided.\n    if (this._dirty) {\n      const player = this._factory.fn(\n          this._element, this._type, this._values !, isFirstRender, currentPlayer || null);\n      this._values = {};\n      this._dirty = false;\n      return player;\n    }\n\n    return undefined;\n  }\n}\n"]}