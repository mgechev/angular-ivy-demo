{"version":3,"file":"injector.js","sourceRoot":"","sources":["../../../../../packages/core/src/di/injector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {injectInjector} from '../render3/di';\nimport {Type} from '../type';\nimport {stringify} from '../util';\nimport {noop} from '../util/noop';\nimport {getClosureSafeProperty} from '../util/property';\n\nimport {defineInjectable} from './defs';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {InjectFlags, inject} from './injector_compatibility';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, ValueProvider} from './provider';\n\nexport const SOURCE = '__source';\nconst _THROW_IF_NOT_FOUND = new Object();\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nexport const INJECTOR = new InjectionToken<Injector>('INJECTOR');\n\nexport class NullInjector implements Injector {\n  get(token: any, notFoundValue: any = _THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === _THROW_IF_NOT_FOUND) {\n      // Intentionally left behind: With dev tools open the debugger will stop here. There is no\n      // reason why correctly written application should cause this exception.\n      // TODO(misko): uncomment the next line once `ngDevMode` works with closure.\n      // if(ngDevMode) debugger;\n      throw new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n    }\n    return notFoundValue;\n  }\n}\n\n/**\n * Concrete injectors implement this interface.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n  static NULL: Injector = new NullInjector();\n\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  /**\n   * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get(token: any, notFoundValue?: any): any;\n\n  /**\n   * @deprecated from v5 use the new signature Injector.create(options)\n   */\n  static create(providers: StaticProvider[], parent?: Injector): Injector;\n\n  static create(options: {providers: StaticProvider[], parent?: Injector, name?: string}): Injector;\n\n  /**\n   * Create a new Injector which is configure using `StaticProvider`s.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n   */\n  static create(\n      options: StaticProvider[]|{providers: StaticProvider[], parent?: Injector, name?: string},\n      parent?: Injector): Injector {\n    if (Array.isArray(options)) {\n      return new StaticInjector(options, parent);\n    } else {\n      return new StaticInjector(options.providers, options.parent, options.name || null);\n    }\n  }\n\n  /** @nocollapse */\n  static ngInjectableDef = defineInjectable({\n    providedIn: 'any' as any,\n    factory: () => inject(INJECTOR),\n  });\n\n  /** @internal */\n  static __NG_ELEMENT_ID__: () => Injector = () => SWITCH_INJECTOR_FACTORY();\n}\n\nexport const SWITCH_INJECTOR_FACTORY__POST_R3__ = function() {\n  return injectInjector();\n};\nconst SWITCH_INJECTOR_FACTORY__PRE_R3__ = noop;\nconst SWITCH_INJECTOR_FACTORY: typeof injectInjector = SWITCH_INJECTOR_FACTORY__PRE_R3__;\n\n\nconst IDENT = function<T>(value: T): T {\n  return value;\n};\nconst EMPTY = <any[]>[];\nconst CIRCULAR = IDENT;\nconst MULTI_PROVIDER_FN = function(): any[] {\n  return Array.prototype.slice.call(arguments);\n};\nexport const USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst enum OptionFlags {\n  Optional = 1 << 0,\n  CheckSelf = 1 << 1,\n  CheckParent = 1 << 2,\n  Default = CheckSelf | CheckParent\n}\nconst NULL_INJECTOR = Injector.NULL;\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'ɵ';\n\nexport class StaticInjector implements Injector {\n  readonly parent: Injector;\n  readonly source: string|null;\n\n  private _records: Map<any, Record>;\n\n  constructor(\n      providers: StaticProvider[], parent: Injector = NULL_INJECTOR, source: string|null = null) {\n    this.parent = parent;\n    this.source = source;\n    const records = this._records = new Map<any, Record>();\n    records.set(\n        Injector, <Record>{token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    records.set(\n        INJECTOR, <Record>{token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    recursivelyProcessProviders(records, providers);\n  }\n\n  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  get(token: any, notFoundValue?: any): any;\n  get(token: any, notFoundValue?: any, flags: InjectFlags = InjectFlags.Default): any {\n    const record = this._records.get(token);\n    try {\n      return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);\n    } catch (e) {\n      const tokenPath: any[] = e[NG_TEMP_TOKEN_PATH];\n      if (token[SOURCE]) {\n        tokenPath.unshift(token[SOURCE]);\n      }\n      e.message = formatError('\\n' + e.message, tokenPath, this.source);\n      e[NG_TOKEN_PATH] = tokenPath;\n      e[NG_TEMP_TOKEN_PATH] = null;\n      throw e;\n    }\n  }\n\n  toString() {\n    const tokens = <string[]>[], records = this._records;\n    records.forEach((v, token) => tokens.push(stringify(token)));\n    return `StaticInjector[${tokens.join(', ')}]`;\n  }\n}\n\ntype SupportedProvider =\n    ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider;\n\ninterface Record {\n  fn: Function;\n  useNew: boolean;\n  deps: DependencyRecord[];\n  value: any;\n}\n\ninterface DependencyRecord {\n  token: any;\n  options: number;\n}\n\ntype TokenPath = Array<any>;\n\nfunction resolveProvider(provider: SupportedProvider): Record {\n  const deps = computeDeps(provider);\n  let fn: Function = IDENT;\n  let value: any = EMPTY;\n  let useNew: boolean = false;\n  let provide = resolveForwardRef(provider.provide);\n  if (USE_VALUE in provider) {\n    // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.\n    value = (provider as ValueProvider).useValue;\n  } else if ((provider as FactoryProvider).useFactory) {\n    fn = (provider as FactoryProvider).useFactory;\n  } else if ((provider as ExistingProvider).useExisting) {\n    // Just use IDENT\n  } else if ((provider as StaticClassProvider).useClass) {\n    useNew = true;\n    fn = resolveForwardRef((provider as StaticClassProvider).useClass);\n  } else if (typeof provide == 'function') {\n    useNew = true;\n    fn = provide;\n  } else {\n    throw staticError(\n        'StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable',\n        provider);\n  }\n  return {deps, fn, useNew, value};\n}\n\nfunction multiProviderMixError(token: any) {\n  return staticError('Cannot mix multi providers and regular providers', token);\n}\n\nfunction recursivelyProcessProviders(records: Map<any, Record>, provider: StaticProvider) {\n  if (provider) {\n    provider = resolveForwardRef(provider);\n    if (provider instanceof Array) {\n      // if we have an array recurse into the array\n      for (let i = 0; i < provider.length; i++) {\n        recursivelyProcessProviders(records, provider[i]);\n      }\n    } else if (typeof provider === 'function') {\n      // Functions were supported in ReflectiveInjector, but are not here. For safety give useful\n      // error messages\n      throw staticError('Function/Class not supported', provider);\n    } else if (provider && typeof provider === 'object' && provider.provide) {\n      // At this point we have what looks like a provider: {provide: ?, ....}\n      let token = resolveForwardRef(provider.provide);\n      const resolvedProvider = resolveProvider(provider);\n      if (provider.multi === true) {\n        // This is a multi provider.\n        let multiProvider: Record|undefined = records.get(token);\n        if (multiProvider) {\n          if (multiProvider.fn !== MULTI_PROVIDER_FN) {\n            throw multiProviderMixError(token);\n          }\n        } else {\n          // Create a placeholder factory which will look up the constituents of the multi provider.\n          records.set(token, multiProvider = <Record>{\n            token: provider.provide,\n            deps: [],\n            useNew: false,\n            fn: MULTI_PROVIDER_FN,\n            value: EMPTY\n          });\n        }\n        // Treat the provider as the token.\n        token = provider;\n        multiProvider.deps.push({token, options: OptionFlags.Default});\n      }\n      const record = records.get(token);\n      if (record && record.fn == MULTI_PROVIDER_FN) {\n        throw multiProviderMixError(token);\n      }\n      records.set(token, resolvedProvider);\n    } else {\n      throw staticError('Unexpected provider', provider);\n    }\n  }\n}\n\nfunction tryResolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  try {\n    return resolveToken(token, record, records, parent, notFoundValue, flags);\n  } catch (e) {\n    // ensure that 'e' is of type Error.\n    if (!(e instanceof Error)) {\n      e = new Error(e);\n    }\n    const path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n    path.unshift(token);\n    if (record && record.value == CIRCULAR) {\n      // Reset the Circular flag.\n      record.value = EMPTY;\n    }\n    throw e;\n  }\n}\n\nfunction resolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  let value;\n  if (record && !(flags & InjectFlags.SkipSelf)) {\n    // If we don't have a record, this implies that we don't own the provider hence don't know how\n    // to resolve it.\n    value = record.value;\n    if (value == CIRCULAR) {\n      throw Error(NO_NEW_LINE + 'Circular dependency');\n    } else if (value === EMPTY) {\n      record.value = CIRCULAR;\n      let obj = undefined;\n      let useNew = record.useNew;\n      let fn = record.fn;\n      let depRecords = record.deps;\n      let deps = EMPTY;\n      if (depRecords.length) {\n        deps = [];\n        for (let i = 0; i < depRecords.length; i++) {\n          const depRecord: DependencyRecord = depRecords[i];\n          const options = depRecord.options;\n          const childRecord =\n              options & OptionFlags.CheckSelf ? records.get(depRecord.token) : undefined;\n          deps.push(tryResolveToken(\n              // Current Token to resolve\n              depRecord.token,\n              // A record which describes how to resolve the token.\n              // If undefined, this means we don't have such a record\n              childRecord,\n              // Other records we know about.\n              records,\n              // If we don't know how to resolve dependency and we should not check parent for it,\n              // than pass in Null injector.\n              !childRecord && !(options & OptionFlags.CheckParent) ? NULL_INJECTOR : parent,\n              options & OptionFlags.Optional ? null : Injector.THROW_IF_NOT_FOUND,\n              InjectFlags.Default));\n        }\n      }\n      record.value = value = useNew ? new (fn as any)(...deps) : fn.apply(obj, deps);\n    }\n  } else if (!(flags & InjectFlags.Self)) {\n    value = parent.get(token, notFoundValue, InjectFlags.Default);\n  }\n  return value;\n}\n\nfunction computeDeps(provider: StaticProvider): DependencyRecord[] {\n  let deps: DependencyRecord[] = EMPTY;\n  const providerDeps: any[] =\n      (provider as ExistingProvider & StaticClassProvider & ConstructorProvider).deps;\n  if (providerDeps && providerDeps.length) {\n    deps = [];\n    for (let i = 0; i < providerDeps.length; i++) {\n      let options = OptionFlags.Default;\n      let token = resolveForwardRef(providerDeps[i]);\n      if (token instanceof Array) {\n        for (let j = 0, annotations = token; j < annotations.length; j++) {\n          const annotation = annotations[j];\n          if (annotation instanceof Optional || annotation == Optional) {\n            options = options | OptionFlags.Optional;\n          } else if (annotation instanceof SkipSelf || annotation == SkipSelf) {\n            options = options & ~OptionFlags.CheckSelf;\n          } else if (annotation instanceof Self || annotation == Self) {\n            options = options & ~OptionFlags.CheckParent;\n          } else if (annotation instanceof Inject) {\n            token = (annotation as Inject).token;\n          } else {\n            token = resolveForwardRef(annotation);\n          }\n        }\n      }\n      deps.push({token, options});\n    }\n  } else if ((provider as ExistingProvider).useExisting) {\n    const token = resolveForwardRef((provider as ExistingProvider).useExisting);\n    deps = [{token, options: OptionFlags.Default}];\n  } else if (!providerDeps && !(USE_VALUE in provider)) {\n    // useValue & useExisting are the only ones which are exempt from deps all others need it.\n    throw staticError('\\'deps\\' required', provider);\n  }\n  return deps;\n}\n\nfunction formatError(text: string, obj: any, source: string | null = null): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;\n  let context = stringify(obj);\n  if (obj instanceof Array) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = <string[]>[];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(\n            key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `StaticInjectorError${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n\nfunction staticError(text: string, obj: any): Error {\n  return new Error(formatError(text, obj));\n}\n"]}