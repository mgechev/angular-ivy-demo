{"version":3,"file":"injector_compatibility.js","sourceRoot":"","sources":["../../../../../packages/core/src/di/injector_compatibility.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {InjectableDef, getInjectableDef} from './defs';\nimport {InjectionToken} from './injection_token';\nimport {Injector} from './injector';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\n\n/**\n * Injection flags for DI.\n *\n * @publicApi\n */\nexport enum InjectFlags {\n  // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.\n\n  Default = 0b0000,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 0b0001,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 0b0010,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 0b0100,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 0b1000,\n}\n\n\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector: Injector|undefined|null = undefined;\n\nexport function setCurrentInjector(injector: Injector | null | undefined): Injector|undefined|null {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation: (<T>(token: Type<T>| InjectionToken<T>, flags: InjectFlags) => T | null)|\n    undefined;\n\n/**\n * Sets the current inject implementation.\n */\nexport function setInjectImplementation(\n    impl: (<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags) => T | null) | undefined):\n    (<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags) => T | null)|undefined {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\n\nexport function injectInjectorOnly<T>(token: Type<T>| InjectionToken<T>): T;\nexport function injectInjectorOnly<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags): T|\n    null;\nexport function injectInjectorOnly<T>(\n    token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  if (_currentInjector === undefined) {\n    throw new Error(`inject() must be called from an injection context`);\n  } else if (_currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n  }\n}\n\n/**\n * Injects a token from the currently active injector.\n *\n * This function must be used in the context of a factory function such as one defined for an\n * `InjectionToken`, and will throw an error if not called from such a context.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='ShakeableInjectionToken'}\n *\n * Within such a factory function `inject` is utilized to request injection of a dependency, instead\n * of providing an additional array of dependencies as was common to do with `useFactory` providers.\n * `inject` is faster and more type-safe.\n *\n * @publicApi\n */\nexport function inject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function inject<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags): T|null;\nexport function inject<T>(token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  return (_injectImplementation || injectInjectorOnly)(token, flags);\n}\n\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * `InjectableDef`.\n */\nexport function injectRootLimpMode<T>(\n    token: Type<T>| InjectionToken<T>, notFoundValue: T | undefined, flags: InjectFlags): T|null {\n  const injectableDef: InjectableDef<T>|null = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n                                               injectableDef.value;\n  }\n  if (flags & InjectFlags.Optional) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);\n}\n\nexport function injectArgs(types: (Type<any>| InjectionToken<any>| any[])[]): any[] {\n  const args: any[] = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = types[i];\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new Error('Arguments array must have arguments.');\n      }\n      let type: Type<any>|undefined = undefined;\n      let flags: InjectFlags = InjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        if (meta instanceof Optional || meta.ngMetadataName === 'Optional') {\n          flags |= InjectFlags.Optional;\n        } else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf') {\n          flags |= InjectFlags.SkipSelf;\n        } else if (meta instanceof Self || meta.ngMetadataName === 'Self') {\n          flags |= InjectFlags.Self;\n        } else if (meta instanceof Inject) {\n          type = meta.token;\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(inject(type !, flags));\n    } else {\n      args.push(inject(arg));\n    }\n  }\n  return args;\n}\n"]}