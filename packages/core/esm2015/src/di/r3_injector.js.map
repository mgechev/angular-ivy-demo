{"version":3,"file":"r3_injector.js","sourceRoot":"","sources":["../../../../../packages/core/src/di/r3_injector.ts"],"names":[],"mappings":";;;;;;;;;;;AAUA,OAAO,EAAC,SAAS,EAAC,MAAM,SAAS,CAAC;AAElC,OAAO,EAAyE,gBAAgB,EAAE,cAAc,EAAC,MAAM,QAAQ,CAAC;AAChI,OAAO,EAAC,iBAAiB,EAAC,MAAM,eAAe,CAAC;AAChD,OAAO,EAAC,cAAc,EAAC,MAAM,mBAAmB,CAAC;AACjD,OAAO,EAAC,QAAQ,EAAY,YAAY,EAAE,kBAAkB,EAAE,SAAS,EAAC,MAAM,YAAY,CAAC;AAC3F,OAAO,EAAC,WAAW,EAAE,MAAM,EAAE,UAAU,EAAE,kBAAkB,EAAC,MAAM,0BAA0B,CAAC;AAE7F,OAAO,EAAC,QAAQ,EAAC,MAAM,SAAS,CAAC;;;;;;AAajC,MAAM,OAAO,GAAG,EAAE,CAAC;;;;;;;;AASnB,MAAM,QAAQ,GAAG,EAAE,CAAC;;AAEpB,MAAM,WAAW,qBAAG,EAAW,EAAC;;;;AAKhC,IAAI,aAAa,GAAuB,SAAS,CAAC;;;;AAElD,SAAS,eAAe;IACtB,IAAI,aAAa,KAAK,SAAS,EAAE;QAC/B,aAAa,GAAG,IAAI,YAAY,EAAE,CAAC;KACpC;IACD,OAAO,aAAa,CAAC;CACtB;;;;;;;;;;;;;;;;;;;;;;;AAiBD,MAAM,UAAU,cAAc,CAC1B,OAAoC,EAAE,SAA0B,IAAI,EACpE,sBAA+C,IAAI;IACrD,MAAM,GAAG,MAAM,IAAI,eAAe,EAAE,CAAC;IACrC,OAAO,IAAI,UAAU,CAAC,OAAO,EAAE,mBAAmB,EAAE,MAAM,CAAC,CAAC;CAC7D;AAED,MAAM,OAAO,UAAU;;;;;;IA2BrB,YACI,GAAsB,EAAE,mBAA0C,EACzD,MAAgB;QAAhB,WAAM,GAAN,MAAM,CAAU;;;;uBAzBX,IAAI,GAAG,EAA8C;;;;gCAK5C,IAAI,GAAG,EAAqB;;;;yBAKnC,IAAI,GAAG,EAAa;;;;yBAWpB,KAAK;;QAOvB,MAAM,UAAU,GAAwB,EAAE,CAAC;QAC3C,WAAW,CAAC,CAAC,GAAG,CAAC,EAAE,WAAW,CAAC,EAAE,CAAC,IAAI,CAAC,mBAAmB,CAAC,WAAW,EAAE,EAAE,EAAE,UAAU,CAAC,CAAC,CAAC;QAEzF,mBAAmB;YACf,WAAW,CAAC,mBAAmB,EAAE,QAAQ,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC;;QAIjF,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC;;;QAIxD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;;QAGjD,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC;KAC7D;;;;;;;;IAQD,OAAO;QACL,IAAI,CAAC,kBAAkB,EAAE,CAAC;;QAG1B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,IAAI;;YAEF,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC;SAC1D;gBAAS;;YAER,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;YACrB,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;YACvB,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,CAAC;SAC/B;KACF;;;;;;;;IAED,GAAG,CACC,KAAgC,EAAE,gBAAqB,kBAAkB,EACzE,KAAK,GAAG,WAAW,CAAC,OAAO;QAC7B,IAAI,CAAC,kBAAkB,EAAE,CAAC;;QAE1B,MAAM,gBAAgB,GAAG,kBAAkB,CAAC,IAAI,CAAC,CAAC;QAClD,IAAI;;YAEF,IAAI,CAAC,CAAC,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC,EAAE;;gBAEnC,IAAI,MAAM,GAAwB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBAC1D,IAAI,MAAM,KAAK,SAAS,EAAE;;oBAGxB,MAAM,GAAG,GAAG,qBAAqB,CAAC,KAAK,CAAC,IAAI,gBAAgB,CAAC,KAAK,CAAC,CAAC;oBACpE,IAAI,GAAG,IAAI,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,EAAE;;;wBAGzC,MAAM,GAAG,UAAU,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC;wBAC1D,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;qBACjC;iBACF;;gBAED,IAAI,MAAM,KAAK,SAAS,EAAE;oBACxB,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;iBACpC;aACF;;YAID,MAAM,YAAY,GAAG,CAAC,CAAC,KAAK,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,eAAe,EAAE,CAAC;YACnF,OAAO,YAAY,CAAC,GAAG,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;SAC/C;gBAAS;;YAER,kBAAkB,CAAC,gBAAgB,CAAC,CAAC;SACtC;KACF;;;;IAEO,kBAAkB;QACxB,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;SACzD;;;;;;;;;;IAOK,mBAAmB,CACvB,eAAiE,EACjE,OAA4B,EAAE,UAA+B;QAC/D,eAAe,GAAG,iBAAiB,CAAC,eAAe,CAAC,CAAC;QACrD,IAAI,CAAC,eAAe;YAAE,OAAO;;QAO7B,IAAI,GAAG,GAAG,cAAc,CAAC,eAAe,CAAC,CAAC;;QAG1C,MAAM,QAAQ,GACV,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,mBAAC,eAAiD,EAAC,CAAC,QAAQ,IAAI,SAAS,CAAC;;QAK/F,MAAM,OAAO,GACT,CAAC,QAAQ,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,mBAAC,eAAoC,EAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;;QAGjF,IAAI,SAAS,IAAI,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE;;YAChD,MAAM,OAAO,GAAG,SAAS,CAAC,OAAO,CAAC,CAAC;YACnC,MAAM,IAAI,KAAK,CACX,+CAA+C,OAAO,sBAAsB,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,OAAO,GAAG,CAAC,CAAC;SACzJ;;QAGD,MAAM,WAAW,GAAG,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;;QAIvD,MAAM,SAAS,GACX,CAAC,QAAQ,KAAK,SAAS,CAAC,IAAI,mBAAC,eAAiD,EAAC,CAAC,SAAS;YACzF,WAAW,CAAC;;;QAIhB,IAAI,QAAQ,KAAK,SAAS,EAAE;YAC1B,GAAG,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC;SAChC;;QAGD,IAAI,GAAG,IAAI,IAAI,EAAE;YACf,OAAO;SACR;;QAGD,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACnC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC;;;QAKnD,IAAI,GAAG,CAAC,OAAO,IAAI,IAAI,IAAI,CAAC,WAAW,EAAE;;;YAGvC,SAAS,IAAI,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;;YAEnC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAEzB,IAAI;gBACF,WAAW,CACP,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE,CAAC,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC,CAAC;aACvF;oBAAS;;gBAER,SAAS,IAAI,OAAO,CAAC,GAAG,EAAE,CAAC;aAC5B;SACF;;QAGD,IAAI,GAAG,CAAC,SAAS,IAAI,IAAI,IAAI,CAAC,WAAW,EAAE;YACzC,WAAW,CAAC,GAAG,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC;SACxE;;QAGD,WAAW,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC;;;;;;;IAM7D,eAAe,CAAC,QAAwB;;;QAG9C,QAAQ,GAAG,iBAAiB,CAAC,QAAQ,CAAC,CAAC;;QACvC,IAAI,KAAK,GAAQ,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,iBAAiB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;;QAG3F,MAAM,MAAM,GAAG,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QAE1C,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,KAAK,KAAK,IAAI,EAAE;;YAGxD,IAAI,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAC1C,IAAI,WAAW,EAAE;;gBAEf,IAAI,WAAW,CAAC,KAAK,KAAK,SAAS,EAAE;oBACnC,MAAM,IAAI,KAAK,CAAC,4BAA4B,KAAK,GAAG,CAAC,CAAC;iBACvD;aACF;iBAAM;gBACL,WAAW,GAAG,UAAU,CAAC,SAAS,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;gBACnD,WAAW,CAAC,OAAO,GAAG,GAAG,EAAE,CAAC,UAAU,uCAAC,WAAW,GAAG,KAAK,GAAG,CAAC;gBAC9D,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;aACtC;YACD,KAAK,GAAG,QAAQ,CAAC;cACjB,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ;SAClC;aAAM;;YACL,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YACzC,IAAI,QAAQ,IAAI,QAAQ,CAAC,KAAK,KAAK,SAAS,EAAE;gBAC5C,MAAM,IAAI,KAAK,CAAC,4BAA4B,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aACjE;SACF;QACD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;;;;;;;;IAG1B,OAAO,CAAI,KAAgC,EAAE,MAAiB;QACpE,IAAI,MAAM,CAAC,KAAK,KAAK,QAAQ,EAAE;YAC7B,MAAM,IAAI,KAAK,CAAC,oBAAoB,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;SACzD;aAAM,IAAI,MAAM,CAAC,KAAK,KAAK,OAAO,EAAE;YACnC,MAAM,CAAC,KAAK,GAAG,QAAQ,CAAC;YACxB,MAAM,CAAC,KAAK,sBAAG,MAAM,CAAC,OAAO,IAAI,CAAC;SACnC;QACD,IAAI,OAAO,MAAM,CAAC,KAAK,KAAK,QAAQ,IAAI,MAAM,CAAC,KAAK,IAAI,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;YAClF,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SAClC;QACD,yBAAO,MAAM,CAAC,KAAU,EAAC;;;;;;IAGnB,oBAAoB,CAAC,GAAuB;QAClD,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE;YACnB,OAAO,KAAK,CAAC;SACd;aAAM,IAAI,OAAO,GAAG,CAAC,UAAU,KAAK,QAAQ,EAAE;YAC7C,OAAO,GAAG,CAAC,UAAU,KAAK,KAAK,IAAI,CAAC,GAAG,CAAC,UAAU,KAAK,MAAM,IAAI,IAAI,CAAC,cAAc,CAAC,CAAC;SACvF;aAAM;YACL,OAAO,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;SAClD;;CAEJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAED,SAAS,oBAAoB,CAAC,KAAqC;;IACjE,MAAM,aAAa,GAAG,gBAAgB,mBAAC,KAA4B,EAAC,CAAC;IACrE,IAAI,aAAa,KAAK,IAAI,EAAE;QAC1B,IAAI,KAAK,YAAY,cAAc,EAAE;YACnC,MAAM,IAAI,KAAK,CAAC,SAAS,SAAS,CAAC,KAAK,CAAC,4CAA4C,CAAC,CAAC;SACxF;;;QAGD,OAAO,GAAG,EAAE,CAAC,IAAI,mBAAC,KAAkB,EAAC,EAAE,CAAC;KACzC;IACD,OAAO,aAAa,CAAC,OAAO,CAAC;CAC9B;;;;;AAED,SAAS,gBAAgB,CAAC,QAAwB;;IAChD,IAAI,OAAO,GAA0B,iBAAiB,CAAC,QAAQ,CAAC,CAAC;IACjE,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;QAC7B,OAAO,UAAU,CAAC,SAAS,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC;KACjD;SAAM;QACL,OAAO,UAAU,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;KACrC;CACF;;;;;;;AAOD,MAAM,UAAU,iBAAiB,CAAC,QAAwB;;IACxD,IAAI,OAAO,GAA0B,SAAS,CAAC;IAC/C,IAAI,cAAc,CAAC,QAAQ,CAAC,EAAE;QAC5B,OAAO,oBAAoB,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC,CAAC;KAC1D;SAAM;QACL,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;YAC7B,OAAO,GAAG,GAAG,EAAE,CAAC,iBAAiB,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;SACtD;aAAM,IAAI,kBAAkB,CAAC,QAAQ,CAAC,EAAE;YACvC,OAAO,GAAG,GAAG,EAAE,CAAC,MAAM,CAAC,iBAAiB,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC;SACjE;aAAM,IAAI,iBAAiB,CAAC,QAAQ,CAAC,EAAE;YACtC,OAAO,GAAG,GAAG,EAAE,CAAC,QAAQ,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC,QAAQ,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC;SACzE;aAAM;;YACL,MAAM,QAAQ,GAAG,iBAAiB,CAC9B,mBAAC,QAA+C,EAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,OAAO,CAAC,CAAC;YACpF,IAAI,OAAO,CAAC,QAAQ,CAAC,EAAE;gBACrB,OAAO,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;aAC9D;iBAAM;gBACL,OAAO,oBAAoB,CAAC,QAAQ,CAAC,CAAC;aACvC;SACF;KACF;IACD,OAAO,OAAO,CAAC;CAChB;;;;;;;;AAED,SAAS,UAAU,CACf,OAA8B,EAAE,QAAgB,OAAO,EAAE,QAAiB,KAAK;IACjF,OAAO;QACL,OAAO,EAAE,OAAO;QAChB,KAAK,EAAE,KAAK;QACZ,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS;KAC9B,CAAC;CACH;;;;;;;AAED,SAAS,WAAW,CAAI,KAAoB,EAAE,EAAsB;IAClE,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;CACnF;;;;;AAED,SAAS,eAAe,CAAC,KAAqB;IAC5C,OAAO,SAAS,IAAI,KAAK,CAAC;CAC3B;;;;;AAED,SAAS,kBAAkB,CAAC,KAAqB;IAC/C,OAAO,CAAC,CAAC,mBAAC,KAAyB,EAAC,CAAC,WAAW,CAAC;CAClD;;;;;AAED,SAAS,iBAAiB,CAAC,KAAqB;IAC9C,OAAO,CAAC,CAAC,mBAAC,KAAwB,EAAC,CAAC,UAAU,CAAC;CAChD;;;;;AAED,MAAM,UAAU,cAAc,CAAC,KAAqB;IAClD,OAAO,OAAO,KAAK,KAAK,UAAU,CAAC;CACpC;;;;;AAED,SAAS,OAAO,CAAC,KAAgE;IAE/E,OAAO,CAAC,CAAC,mBAAC,KAAY,EAAC,CAAC,IAAI,CAAC;CAC9B;;;;;AAED,SAAS,YAAY,CAAC,KAAU;IAC9B,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,IAAI,IAAI,IAAI,mBAAC,KAAkB,EAAC,CAAC,WAAW;QACjF,OAAM,mBAAC,KAAkB,EAAC,CAAC,WAAW,KAAK,UAAU,CAAC;CAC3D;;;;;AAED,SAAS,qBAAqB,CAAC,KAAU;IACvC,OAAO,CAAC,OAAO,KAAK,KAAK,UAAU,CAAC;QAChC,CAAC,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,YAAY,cAAc,CAAC,CAAC;CACpE","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OnDestroy} from '../metadata/lifecycle_hooks';\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {InjectableDef, InjectableType, InjectorType, InjectorTypeWithProviders, getInjectableDef, getInjectorDef} from './defs';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {INJECTOR, Injector, NullInjector, THROW_IF_NOT_FOUND, USE_VALUE} from './injector';\nimport {InjectFlags, inject, injectArgs, setCurrentInjector} from './injector_compatibility';\nimport {ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, Provider, StaticClassProvider, StaticProvider, TypeProvider, ValueProvider} from './provider';\nimport {APP_ROOT} from './scope';\n\n\n\n/**\n * Internal type for a single provider in a deep provider array.\n */\ntype SingleProvider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider |\n    ExistingProvider | FactoryProvider | StaticClassProvider;\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n\nconst EMPTY_ARRAY = [] as any[];\n\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR: Injector|undefined = undefined;\n\nfunction getNullInjector(): Injector {\n  if (NULL_INJECTOR === undefined) {\n    NULL_INJECTOR = new NullInjector();\n  }\n  return NULL_INJECTOR;\n}\n\n/**\n * An entry in the injector which tracks information about the given token, including a possible\n * current value.\n */\ninterface Record<T> {\n  factory: (() => T)|undefined;\n  value: T|{};\n  multi: any[]|undefined;\n}\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n *\n * @publicApi\n */\nexport function createInjector(\n    defType: /* InjectorType<any> */ any, parent: Injector | null = null,\n    additionalProviders: StaticProvider[] | null = null): Injector {\n  parent = parent || getNullInjector();\n  return new R3Injector(defType, additionalProviders, parent);\n}\n\nexport class R3Injector {\n  /**\n   * Map of tokens to records which contain the instances of those tokens.\n   */\n  private records = new Map<Type<any>|InjectionToken<any>, Record<any>>();\n\n  /**\n   * The transitive set of `InjectorType`s which define this injector.\n   */\n  private injectorDefTypes = new Set<InjectorType<any>>();\n\n  /**\n   * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n   */\n  private onDestroy = new Set<OnDestroy>();\n\n  /**\n   * Flag indicating this injector provides the APP_ROOT_SCOPE token, and thus counts as the\n   * root scope.\n   */\n  private readonly isRootInjector: boolean;\n\n  /**\n   * Flag indicating that this injector was previously destroyed.\n   */\n  private destroyed = false;\n\n  constructor(\n      def: InjectorType<any>, additionalProviders: StaticProvider[]|null,\n      readonly parent: Injector) {\n    // Start off by creating Records for every provider declared in every InjectorType\n    // included transitively in `def`.\n    const dedupStack: InjectorType<any>[] = [];\n    deepForEach([def], injectorDef => this.processInjectorType(injectorDef, [], dedupStack));\n\n    additionalProviders &&\n        deepForEach(additionalProviders, provider => this.processProvider(provider));\n\n\n    // Make sure the INJECTOR token provides this injector.\n    this.records.set(INJECTOR, makeRecord(undefined, this));\n\n    // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n    // any injectable scoped to APP_ROOT_SCOPE.\n    this.isRootInjector = this.records.has(APP_ROOT);\n\n    // Eagerly instantiate the InjectorType classes themselves.\n    this.injectorDefTypes.forEach(defType => this.get(defType));\n  }\n\n  /**\n   * Destroy the injector and release references to every instance or provider associated with it.\n   *\n   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n   * hook was found.\n   */\n  destroy(): void {\n    this.assertNotDestroyed();\n\n    // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n    this.destroyed = true;\n    try {\n      // Call all the lifecycle hooks.\n      this.onDestroy.forEach(service => service.ngOnDestroy());\n    } finally {\n      // Release all references.\n      this.records.clear();\n      this.onDestroy.clear();\n      this.injectorDefTypes.clear();\n    }\n  }\n\n  get<T>(\n      token: Type<T>|InjectionToken<T>, notFoundValue: any = THROW_IF_NOT_FOUND,\n      flags = InjectFlags.Default): T {\n    this.assertNotDestroyed();\n    // Set the injection context.\n    const previousInjector = setCurrentInjector(this);\n    try {\n      // Check for the SkipSelf flag.\n      if (!(flags & InjectFlags.SkipSelf)) {\n        // SkipSelf isn't set, check if the record belongs to this injector.\n        let record: Record<T>|undefined = this.records.get(token);\n        if (record === undefined) {\n          // No record, but maybe the token is scoped to this injector. Look for an ngInjectableDef\n          // with a scope matching this injector.\n          const def = couldBeInjectableType(token) && getInjectableDef(token);\n          if (def && this.injectableDefInScope(def)) {\n            // Found an ngInjectableDef and it's scoped to this injector. Pretend as if it was here\n            // all along.\n            record = makeRecord(injectableDefFactory(token), NOT_YET);\n            this.records.set(token, record);\n          }\n        }\n        // If a record was found, get the instance for it and return it.\n        if (record !== undefined) {\n          return this.hydrate(token, record);\n        }\n      }\n\n      // Select the next injector based on the Self flag - if self is set, the next injector is\n      // the NullInjector, otherwise it's the parent.\n      const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n      return nextInjector.get(token, notFoundValue);\n    } finally {\n      // Lastly, clean up the state by restoring the previous injector.\n      setCurrentInjector(previousInjector);\n    }\n  }\n\n  private assertNotDestroyed(): void {\n    if (this.destroyed) {\n      throw new Error('Injector has already been destroyed.');\n    }\n  }\n\n  /**\n   * Add an `InjectorType` or `InjectorDefTypeWithProviders` and all of its transitive providers\n   * to this injector.\n   */\n  private processInjectorType(\n      defOrWrappedDef: InjectorType<any>|InjectorTypeWithProviders<any>,\n      parents: InjectorType<any>[], dedupStack: InjectorType<any>[]) {\n    defOrWrappedDef = resolveForwardRef(defOrWrappedDef);\n    if (!defOrWrappedDef) return;\n\n    // Either the defOrWrappedDef is an InjectorType (with ngInjectorDef) or an\n    // InjectorDefTypeWithProviders (aka ModuleWithProviders). Detecting either is a megamorphic\n    // read, so care is taken to only do the read once.\n\n    // First attempt to read the ngInjectorDef.\n    let def = getInjectorDef(defOrWrappedDef);\n\n    // If that's not present, then attempt to read ngModule from the InjectorDefTypeWithProviders.\n    const ngModule =\n        (def == null) && (defOrWrappedDef as InjectorTypeWithProviders<any>).ngModule || undefined;\n\n    // Determine the InjectorType. In the case where `defOrWrappedDef` is an `InjectorType`,\n    // then this is easy. In the case of an InjectorDefTypeWithProviders, then the definition type\n    // is the `ngModule`.\n    const defType: InjectorType<any> =\n        (ngModule === undefined) ? (defOrWrappedDef as InjectorType<any>) : ngModule;\n\n    // Check for circular dependencies.\n    if (ngDevMode && parents.indexOf(defType) !== -1) {\n      const defName = stringify(defType);\n      throw new Error(\n          `Circular dependency in DI detected for type ${defName}. Dependency path: ${parents.map(defType => stringify(defType)).join(' > ')} > ${defName}.`);\n    }\n\n    // Check for multiple imports of the same module\n    const isDuplicate = dedupStack.indexOf(defType) !== -1;\n\n    // If defOrWrappedType was an InjectorDefTypeWithProviders, then .providers may hold some\n    // extra providers.\n    const providers =\n        (ngModule !== undefined) && (defOrWrappedDef as InjectorTypeWithProviders<any>).providers ||\n        EMPTY_ARRAY;\n\n    // Finally, if defOrWrappedType was an `InjectorDefTypeWithProviders`, then the actual\n    // `InjectorDef` is on its `ngModule`.\n    if (ngModule !== undefined) {\n      def = getInjectorDef(ngModule);\n    }\n\n    // If no definition was found, it might be from exports. Remove it.\n    if (def == null) {\n      return;\n    }\n\n    // Track the InjectorType and add a provider for it.\n    this.injectorDefTypes.add(defType);\n    this.records.set(defType, makeRecord(def.factory));\n\n    // Add providers in the same way that @NgModule resolution did:\n\n    // First, include providers from any imports.\n    if (def.imports != null && !isDuplicate) {\n      // Before processing defType's imports, add it to the set of parents. This way, if it ends\n      // up deeply importing itself, this can be detected.\n      ngDevMode && parents.push(defType);\n      // Add it to the set of dedups. This way we can detect multiple imports of the same module\n      dedupStack.push(defType);\n\n      try {\n        deepForEach(\n            def.imports, imported => this.processInjectorType(imported, parents, dedupStack));\n      } finally {\n        // Remove it from the parents set when finished.\n        ngDevMode && parents.pop();\n      }\n    }\n\n    // Next, include providers listed on the definition itself.\n    if (def.providers != null && !isDuplicate) {\n      deepForEach(def.providers, provider => this.processProvider(provider));\n    }\n\n    // Finally, include providers from an InjectorDefTypeWithProviders if there was one.\n    deepForEach(providers, provider => this.processProvider(provider));\n  }\n\n  /**\n   * Process a `SingleProvider` and add it.\n   */\n  private processProvider(provider: SingleProvider): void {\n    // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n    // property.\n    provider = resolveForwardRef(provider);\n    let token: any = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n\n    // Construct a `Record` for the provider.\n    const record = providerToRecord(provider);\n\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      // If the provider indicates that it's a multi-provider, process it specially.\n      // First check whether it's been defined already.\n      let multiRecord = this.records.get(token);\n      if (multiRecord) {\n        // It has. Throw a nice error if\n        if (multiRecord.multi === undefined) {\n          throw new Error(`Mixed multi-provider for ${token}.`);\n        }\n      } else {\n        multiRecord = makeRecord(undefined, NOT_YET, true);\n        multiRecord.factory = () => injectArgs(multiRecord !.multi !);\n        this.records.set(token, multiRecord);\n      }\n      token = provider;\n      multiRecord.multi !.push(provider);\n    } else {\n      const existing = this.records.get(token);\n      if (existing && existing.multi !== undefined) {\n        throw new Error(`Mixed multi-provider for ${stringify(token)}`);\n      }\n    }\n    this.records.set(token, record);\n  }\n\n  private hydrate<T>(token: Type<T>|InjectionToken<T>, record: Record<T>): T {\n    if (record.value === CIRCULAR) {\n      throw new Error(`Circular dep for ${stringify(token)}`);\n    } else if (record.value === NOT_YET) {\n      record.value = CIRCULAR;\n      record.value = record.factory !();\n    }\n    if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n      this.onDestroy.add(record.value);\n    }\n    return record.value as T;\n  }\n\n  private injectableDefInScope(def: InjectableDef<any>): boolean {\n    if (!def.providedIn) {\n      return false;\n    } else if (typeof def.providedIn === 'string') {\n      return def.providedIn === 'any' || (def.providedIn === 'root' && this.isRootInjector);\n    } else {\n      return this.injectorDefTypes.has(def.providedIn);\n    }\n  }\n}\n\nfunction injectableDefFactory(token: Type<any>| InjectionToken<any>): () => any {\n  const injectableDef = getInjectableDef(token as InjectableType<any>);\n  if (injectableDef === null) {\n    if (token instanceof InjectionToken) {\n      throw new Error(`Token ${stringify(token)} is missing an ngInjectableDef definition.`);\n    }\n    // TODO(alxhub): there should probably be a strict mode which throws here instead of assuming a\n    // no-args constructor.\n    return () => new (token as Type<any>)();\n  }\n  return injectableDef.factory;\n}\n\nfunction providerToRecord(provider: SingleProvider): Record<any> {\n  let factory: (() => any)|undefined = providerToFactory(provider);\n  if (isValueProvider(provider)) {\n    return makeRecord(undefined, provider.useValue);\n  } else {\n    return makeRecord(factory, NOT_YET);\n  }\n}\n\n/**\n * Converts a `SingleProvider` into a factory function.\n *\n * @param provider provider to convert to factory\n */\nexport function providerToFactory(provider: SingleProvider): () => any {\n  let factory: (() => any)|undefined = undefined;\n  if (isTypeProvider(provider)) {\n    return injectableDefFactory(resolveForwardRef(provider));\n  } else {\n    if (isValueProvider(provider)) {\n      factory = () => resolveForwardRef(provider.useValue);\n    } else if (isExistingProvider(provider)) {\n      factory = () => inject(resolveForwardRef(provider.useExisting));\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else {\n      const classRef = resolveForwardRef(\n          (provider as StaticClassProvider | ClassProvider).useClass || provider.provide);\n      if (hasDeps(provider)) {\n        factory = () => new (classRef)(...injectArgs(provider.deps));\n      } else {\n        return injectableDefFactory(classRef);\n      }\n    }\n  }\n  return factory;\n}\n\nfunction makeRecord<T>(\n    factory: (() => T) | undefined, value: T | {} = NOT_YET, multi: boolean = false): Record<T> {\n  return {\n    factory: factory,\n    value: value,\n    multi: multi ? [] : undefined,\n  };\n}\n\nfunction deepForEach<T>(input: (T | any[])[], fn: (value: T) => void): void {\n  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\n\nfunction isValueProvider(value: SingleProvider): value is ValueProvider {\n  return USE_VALUE in value;\n}\n\nfunction isExistingProvider(value: SingleProvider): value is ExistingProvider {\n  return !!(value as ExistingProvider).useExisting;\n}\n\nfunction isFactoryProvider(value: SingleProvider): value is FactoryProvider {\n  return !!(value as FactoryProvider).useFactory;\n}\n\nexport function isTypeProvider(value: SingleProvider): value is TypeProvider {\n  return typeof value === 'function';\n}\n\nfunction hasDeps(value: ClassProvider | ConstructorProvider | StaticClassProvider):\n    value is ClassProvider&{deps: any[]} {\n  return !!(value as any).deps;\n}\n\nfunction hasOnDestroy(value: any): value is OnDestroy {\n  return typeof value === 'object' && value != null && (value as OnDestroy).ngOnDestroy &&\n      typeof(value as OnDestroy).ngOnDestroy === 'function';\n}\n\nfunction couldBeInjectableType(value: any): value is Type<any>|InjectionToken<any> {\n  return (typeof value === 'function') ||\n      (typeof value === 'object' && value instanceof InjectionToken);\n}\n"]}