{"version":3,"file":"change_detector_ref.js","sourceRoot":"","sources":["../../../../../packages/core/src/change_detection/change_detector_ref.ts"],"names":[],"mappings":";;;;;;;;;;;AAQA,OAAO,EAAC,uBAAuB,IAAI,8BAA8B,EAAC,MAAM,sCAAsC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4C/G,MAAM,OAAgB,iBAAiB;;;;;AA0DrC,sCAAoD,GAAG,EAAE,CAAC,kCAAkC,EAAE,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKjG,aAAa,6CAA6C,GAAG,8BAA8B,CAAC;;AAC5F,MAAM,4CAA4C,GAAG,CAAC,GAAG,IAAW,EAAO,EAAE,IAAG,CAAC;;;AACjF,MAAM,kCAAkC,GACpC,4CAA4C,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {injectChangeDetectorRef as render3InjectChangeDetectorRef} from '../render3/view_engine_compatibility';\n\n/**\n * Base class for Angular Views, provides change detection functionality.\n * A change-detection tree collects all views that are to be checked for changes.\n * Use the methods to add and remove views from the tree, initiate change-detection,\n * and explicitly mark views as _dirty_, meaning that they have changed and need to be rerendered.\n *\n * @usageNotes\n *\n * The following examples demonstrate how to modify default change-detection behavior\n * to perform explicit detection when needed.\n *\n * ### Use `markForCheck()` with `CheckOnce` strategy\n *\n * The following example sets the `OnPush` change-detection strategy for a component\n * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check\n * after an interval. See [live demo](http://plnkr.co/edit/GC512b?p=preview).\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\"\n * region=\"mark-for-check\"></code-example>\n *\n * ### Detach change detector to limit how often check occurs\n *\n * The following example defines a component with a large list of read-only data\n * that is expected to change constantly, many times per second.\n * To improve performance, we want to check and update the list\n * less often than the changes actually occur. To do that, we detach\n * the component's change detector and perform an explicit local check every five seconds.\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"detach\"></code-example>\n *\n *\n * ### Reattaching a detached component\n *\n * The following example creates a component displaying live data.\n * The component detaches its change detector from the main change detector tree\n * when the `live` property is set to false, and reattaches it when the property\n * becomes true.\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"reattach\"></code-example>\n *\n * @publicApi\n */\nexport abstract class ChangeDetectorRef {\n  /**\n   * When a view uses the {@link ChangeDetectionStrategy#OnPush OnPush} (checkOnce)\n   * change detection strategy, explicitly marks the view as changed so that\n   * it can be checked again.\n   *\n   * Components are normally marked as dirty (in need of rerendering) when inputs\n   * have changed or events have fired in the view. Call this method to ensure that\n   * a component is checked even if these triggers have not occured.\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   */\n  abstract markForCheck(): void;\n\n  /**\n   * Detaches this view from the change-detection tree.\n   * A detached view is  not checked until it is reattached.\n   * Use in combination with `detectChanges()` to implement local change detection checks.\n   *\n   * Detached views are not checked during change detection runs until they are\n   * re-attached, even if they are marked as dirty.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   */\n  abstract detach(): void;\n\n  /**\n   * Checks this view and its children. Use in combination with {@link ChangeDetectorRef#detach\n   * detach}\n   * to implement local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   */\n  abstract detectChanges(): void;\n\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * Use in development mode to verify that running change detection doesn't introduce\n   * other changes.\n   */\n  abstract checkNoChanges(): void;\n\n  /**\n   * Re-attaches the previously detached view to the change detection tree.\n   * Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   */\n  abstract reattach(): void;\n\n  /** @internal */\n  static __NG_ELEMENT_ID__: () => ChangeDetectorRef = () => SWITCH_CHANGE_DETECTOR_REF_FACTORY();\n}\n\n\n\nexport const SWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__ = render3InjectChangeDetectorRef;\nconst SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__ = (...args: any[]): any => {};\nconst SWITCH_CHANGE_DETECTOR_REF_FACTORY: typeof render3InjectChangeDetectorRef =\n    SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__;\n"]}