{"version":3,"file":"element_ref.js","sourceRoot":"","sources":["../../../../../../packages/core/src/linker/element_ref.ts"],"names":[],"mappings":";;;;;;;;;;;AAQA,OAAO,EAAC,gBAAgB,IAAI,uBAAuB,EAAC,MAAM,sCAAsC,CAAC;AACjG,OAAO,EAAC,IAAI,EAAC,MAAM,cAAc,CAAC;;;;;;;;;;;;;;;IAyChC,oBAAY,aAAgB;QAAI,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;KAAE;;;;IAGrE,+BAA6C,cAAM,OAAA,0BAA0B,CAAC,UAAU,CAAC,EAAtC,CAAsC,CAAC;qBArD5F;;SA0Ba,UAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BvB,WAAa,qCAAqC,GAAG,uBAAuB,CAAC;;AAC7E,IAAM,oCAAoC,GAAG,IAAI,CAAC;;AAClD,IAAM,0BAA0B,GAC5B,oCAAoC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {injectElementRef as render3InjectElementRef} from '../render3/view_engine_compatibility';\nimport {noop} from '../util/noop';\n\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](http://g.co/ng/security).\n *\n * @publicApi\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\nexport class ElementRef<T = any> {\n  /**\n   * The underlying native element or `null` if direct access to native elements is not supported\n   * (e.g. when the application runs in a web worker).\n   *\n   * <div class=\"callout is-critical\">\n   *   <header>Use with caution</header>\n   *   <p>\n   *    Use this API as the last resort when direct access to DOM is needed. Use templating and\n   *    data-binding provided by Angular instead. Alternatively you can take a look at {@link\n   * Renderer2}\n   *    which provides API that can safely be used even when direct access to native elements is not\n   *    supported.\n   *   </p>\n   *   <p>\n   *    Relying on direct DOM access creates tight coupling between your application and rendering\n   *    layers which will make it impossible to separate the two and deploy your application into a\n   *    web worker.\n   *   </p>\n   * </div>\n   *\n   */\n  public nativeElement: T;\n\n  constructor(nativeElement: T) { this.nativeElement = nativeElement; }\n\n  /** @internal */\n  static __NG_ELEMENT_ID__: () => ElementRef = () => SWITCH_ELEMENT_REF_FACTORY(ElementRef);\n}\n\nexport const SWITCH_ELEMENT_REF_FACTORY__POST_R3__ = render3InjectElementRef;\nconst SWITCH_ELEMENT_REF_FACTORY__PRE_R3__ = noop;\nconst SWITCH_ELEMENT_REF_FACTORY: typeof render3InjectElementRef =\n    SWITCH_ELEMENT_REF_FACTORY__PRE_R3__;\n"]}