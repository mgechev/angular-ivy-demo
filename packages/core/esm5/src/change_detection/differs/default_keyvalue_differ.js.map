{"version":3,"file":"default_keyvalue_differ.js","sourceRoot":"","sources":["../../../../../../../packages/core/src/change_detection/differs/default_keyvalue_differ.ts"],"names":[],"mappings":";;;;;;;;;;;AAQA,OAAO,EAAC,cAAc,EAAE,SAAS,EAAC,MAAM,YAAY,CAAC;AACrD,OAAO,EAAC,UAAU,EAAC,MAAM,0BAA0B,CAAC;;;;AAIpD;;;AAAA;IACE;KAAgB;;;;;IAChB,+CAAQ;;;;IAAR,UAAS,GAAQ,IAAa,OAAO,GAAG,YAAY,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;;;;;IAE7E,6CAAM;;;;IAAN,cAAuC,OAAO,IAAI,qBAAqB,EAAQ,CAAC,EAAE;uCAjBpF;IAkBC,CAAA;;;;AALD,wCAKC;;;;AAED;;;AAAA;;wBACqB,IAAI,GAAG,EAAkC;wBACP,IAAI;4BAEA,IAAI;gCACA,IAAI;4BACR,IAAI;4BACJ,IAAI;8BACF,IAAI;8BACJ,IAAI;6BACL,IAAI;6BACJ,IAAI;;IAE9D,sBAAI,0CAAO;;;;QAAX;YACE,OAAO,IAAI,CAAC,cAAc,KAAK,IAAI,IAAI,IAAI,CAAC,YAAY,KAAK,IAAI;gBAC7D,IAAI,CAAC,aAAa,KAAK,IAAI,CAAC;SACjC;;;OAAA;;;;;IAED,2CAAW;;;;IAAX,UAAY,EAA2C;;QACrD,IAAI,MAAM,CAAmC;QAC7C,KAAK,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,MAAM,KAAK,IAAI,EAAE,MAAM,GAAG,MAAM,CAAC,KAAK,EAAE;YACnE,EAAE,CAAC,MAAM,CAAC,CAAC;SACZ;KACF;;;;;IAED,mDAAmB;;;;IAAnB,UAAoB,EAA2C;;QAC7D,IAAI,MAAM,CAAmC;QAC7C,KAAK,MAAM,GAAG,IAAI,CAAC,gBAAgB,EAAE,MAAM,KAAK,IAAI,EAAE,MAAM,GAAG,MAAM,CAAC,aAAa,EAAE;YACnF,EAAE,CAAC,MAAM,CAAC,CAAC;SACZ;KACF;;;;;IAED,kDAAkB;;;;IAAlB,UAAmB,EAA2C;;QAC5D,IAAI,MAAM,CAAmC;QAC7C,KAAK,MAAM,GAAG,IAAI,CAAC,YAAY,EAAE,MAAM,KAAK,IAAI,EAAE,MAAM,GAAG,MAAM,CAAC,YAAY,EAAE;YAC9E,EAAE,CAAC,MAAM,CAAC,CAAC;SACZ;KACF;;;;;IAED,gDAAgB;;;;IAAhB,UAAiB,EAA2C;;QAC1D,IAAI,MAAM,CAAmC;QAC7C,KAAK,MAAM,GAAG,IAAI,CAAC,cAAc,EAAE,MAAM,KAAK,IAAI,EAAE,MAAM,GAAG,MAAM,CAAC,UAAU,EAAE;YAC9E,EAAE,CAAC,MAAM,CAAC,CAAC;SACZ;KACF;;;;;IAED,kDAAkB;;;;IAAlB,UAAmB,EAA2C;;QAC5D,IAAI,MAAM,CAAmC;QAC7C,KAAK,MAAM,GAAG,IAAI,CAAC,aAAa,EAAE,MAAM,KAAK,IAAI,EAAE,MAAM,GAAG,MAAM,CAAC,YAAY,EAAE;YAC/E,EAAE,CAAC,MAAM,CAAC,CAAC;SACZ;KACF;;;;;IAED,oCAAI;;;;IAAJ,UAAK,GAA2C;QAC9C,IAAI,CAAC,GAAG,EAAE;YACR,GAAG,GAAG,IAAI,GAAG,EAAE,CAAC;SACjB;aAAM,IAAI,CAAC,CAAC,GAAG,YAAY,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;YACnD,MAAM,IAAI,KAAK,CACX,2BAAyB,SAAS,CAAC,GAAG,CAAC,yCAAsC,CAAC,CAAC;SACpF;QAED,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;KACtC;;;;IAED,yCAAS;;;IAAT,eAAc;IAEd;;;OAGG;;;;;;;IACH,qCAAK;;;;;;IAAL,UAAM,GAAqC;QAA3C,iBA4CC;QA3CC,IAAI,CAAC,MAAM,EAAE,CAAC;;QAEd,IAAI,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC;QACjC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QAEzB,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,UAAC,KAAU,EAAE,GAAQ;YACtC,IAAI,YAAY,IAAI,YAAY,CAAC,GAAG,KAAK,GAAG,EAAE;gBAC5C,KAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;gBAC7C,KAAI,CAAC,YAAY,GAAG,YAAY,CAAC;gBACjC,YAAY,GAAG,YAAY,CAAC,KAAK,CAAC;aACnC;iBAAM;;gBACL,IAAM,MAAM,GAAG,KAAI,CAAC,wBAAwB,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;gBACzD,YAAY,GAAG,KAAI,CAAC,qBAAqB,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;aACjE;SACF,CAAC,CAAC;;QAGH,IAAI,YAAY,EAAE;YAChB,IAAI,YAAY,CAAC,KAAK,EAAE;gBACtB,YAAY,CAAC,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC;aACjC;YAED,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC;YAElC,KAAK,IAAI,MAAM,GAAqC,YAAY,EAAE,MAAM,KAAK,IAAI,EAC5E,MAAM,GAAG,MAAM,CAAC,YAAY,EAAE;gBACjC,IAAI,MAAM,KAAK,IAAI,CAAC,QAAQ,EAAE;oBAC5B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;iBACtB;gBACD,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;gBACjC,MAAM,CAAC,YAAY,GAAG,MAAM,CAAC,KAAK,CAAC;gBACnC,MAAM,CAAC,aAAa,GAAG,MAAM,CAAC,YAAY,CAAC;gBAC3C,MAAM,CAAC,YAAY,GAAG,IAAI,CAAC;gBAC3B,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC;gBACpB,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC;aACrB;SACF;;QAGD,IAAI,IAAI,CAAC,YAAY;YAAE,IAAI,CAAC,YAAY,CAAC,YAAY,GAAG,IAAI,CAAC;QAC7D,IAAI,IAAI,CAAC,cAAc;YAAE,IAAI,CAAC,cAAc,CAAC,UAAU,GAAG,IAAI,CAAC;QAE/D,OAAO,IAAI,CAAC,OAAO,CAAC;KACrB;;;;;;;;;;;;IAUO,qDAAqB;;;;;;;;;;;cACzB,MAAwC,EACxC,MAAmC;QACrC,IAAI,MAAM,EAAE;;YACV,IAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC;YAC1B,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC;YACtB,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC;YACpB,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC;YACtB,IAAI,IAAI,EAAE;gBACR,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC;aACrB;YACD,IAAI,MAAM,KAAK,IAAI,CAAC,QAAQ,EAAE;gBAC5B,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC;aACxB;YAED,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC;YAC3B,OAAO,MAAM,CAAC;SACf;QAED,IAAI,IAAI,CAAC,YAAY,EAAE;YACrB,IAAI,CAAC,YAAY,CAAC,KAAK,GAAG,MAAM,CAAC;YACjC,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC;SAClC;aAAM;YACL,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC;SACxB;QAED,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC;QAC3B,OAAO,IAAI,CAAC;;;;;;;IAGN,wDAAwB;;;;;cAAC,GAAM,EAAE,KAAQ;QAC/C,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;;YAC1B,IAAM,QAAM,sBAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG;YACxC,IAAI,CAAC,kBAAkB,CAAC,QAAM,EAAE,KAAK,CAAC,CAAC;;YACvC,IAAM,IAAI,GAAG,QAAM,CAAC,KAAK,CAAC;;YAC1B,IAAM,IAAI,GAAG,QAAM,CAAC,KAAK,CAAC;YAC1B,IAAI,IAAI,EAAE;gBACR,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;aACnB;YACD,IAAI,IAAI,EAAE;gBACR,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;aACnB;YACD,QAAM,CAAC,KAAK,GAAG,IAAI,CAAC;YACpB,QAAM,CAAC,KAAK,GAAG,IAAI,CAAC;YAEpB,OAAO,QAAM,CAAC;SACf;;QAED,IAAM,MAAM,GAAG,IAAI,qBAAqB,CAAO,GAAG,CAAC,CAAC;QACpD,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QAC/B,MAAM,CAAC,YAAY,GAAG,KAAK,CAAC;QAC5B,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;QAC7B,OAAO,MAAM,CAAC;;IAGhB,gBAAgB;;;;;IAChB,sCAAM;;;;IAAN;QACE,IAAI,IAAI,CAAC,OAAO,EAAE;;YAChB,IAAI,MAAM,UAAmC;;YAE7C,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,QAAQ,CAAC;YACtC,KAAK,MAAM,GAAG,IAAI,CAAC,gBAAgB,EAAE,MAAM,KAAK,IAAI,EAAE,MAAM,GAAG,MAAM,CAAC,KAAK,EAAE;gBAC3E,MAAM,CAAC,aAAa,GAAG,MAAM,CAAC,KAAK,CAAC;aACrC;;;YAID,KAAK,MAAM,GAAG,IAAI,CAAC,YAAY,EAAE,MAAM,KAAK,IAAI,EAAE,MAAM,GAAG,MAAM,CAAC,YAAY,EAAE;gBAC9E,MAAM,CAAC,aAAa,GAAG,MAAM,CAAC,YAAY,CAAC;aAC5C;YACD,KAAK,MAAM,GAAG,IAAI,CAAC,cAAc,EAAE,MAAM,IAAI,IAAI,EAAE,MAAM,GAAG,MAAM,CAAC,UAAU,EAAE;gBAC7E,MAAM,CAAC,aAAa,GAAG,MAAM,CAAC,YAAY,CAAC;aAC5C;YAED,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;YAC7C,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;YACjD,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;SAC3B;KACF;;;;;;IAGO,kDAAkB;;;;;cAAC,MAAmC,EAAE,QAAa;QAC3E,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,MAAM,CAAC,YAAY,CAAC,EAAE;YAClD,MAAM,CAAC,aAAa,GAAG,MAAM,CAAC,YAAY,CAAC;YAC3C,MAAM,CAAC,YAAY,GAAG,QAAQ,CAAC;YAC/B,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;SAC5B;;;;;;IAGK,+CAAe;;;;cAAC,MAAmC;QACzD,IAAI,IAAI,CAAC,cAAc,KAAK,IAAI,EAAE;YAChC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC;SACpD;aAAM;+BACL,IAAI,CAAC,cAAc,GAAG,UAAU,GAAG,MAAM;YACzC,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC;SAC9B;;;;;;IAGK,6CAAa;;;;cAAC,MAAmC;QACvD,IAAI,IAAI,CAAC,YAAY,KAAK,IAAI,EAAE;YAC9B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC;SAChD;aAAM;+BACL,IAAI,CAAC,YAAY,GAAG,YAAY,GAAG,MAAM;YACzC,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC;SAC5B;;;;;;;;;IAIK,wCAAQ;;;;;;;cAAO,GAA+B,EAAE,EAA0B;QAChF,IAAI,GAAG,YAAY,GAAG,EAAE;YACtB,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;SACjB;aAAM;YACL,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAA,CAAC,IAAI,OAAA,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAb,CAAa,CAAC,CAAC;SAC9C;;gCAjQL;IAmQC,CAAA;;;;AA/OD,iCA+OC;;;;;;;;;;;;;;;;;;;;;;;;;;AAED;;;AAAA;IAiBE,+BAAmB,GAAM;QAAN,QAAG,GAAH,GAAG,CAAG;QAhBzB,qBAAwB,IAAI,CAAC;QAC7B,oBAAuB,IAAI,CAAC;;;;QAG5B,qBAAkD,IAAI,CAAC;;;;QAEvD,aAA0C,IAAI,CAAC;;;;QAE/C,aAA0C,IAAI,CAAC;;;;QAE/C,kBAA+C,IAAI,CAAC;;;;QAEpD,oBAAiD,IAAI,CAAC;;;;QAEtD,oBAAiD,IAAI,CAAC;KAEzB;gCAtR/B;IAuRC,CAAA","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {looseIdentical, stringify} from '../../util';\nimport {isJsObject} from '../change_detection_util';\nimport {KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory} from './keyvalue_differs';\n\n\nexport class DefaultKeyValueDifferFactory<K, V> implements KeyValueDifferFactory {\n  constructor() {}\n  supports(obj: any): boolean { return obj instanceof Map || isJsObject(obj); }\n\n  create<K, V>(): KeyValueDiffer<K, V> { return new DefaultKeyValueDiffer<K, V>(); }\n}\n\nexport class DefaultKeyValueDiffer<K, V> implements KeyValueDiffer<K, V>, KeyValueChanges<K, V> {\n  private _records = new Map<K, KeyValueChangeRecord_<K, V>>();\n  private _mapHead: KeyValueChangeRecord_<K, V>|null = null;\n  // _appendAfter is used in the check loop\n  private _appendAfter: KeyValueChangeRecord_<K, V>|null = null;\n  private _previousMapHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _changesHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _changesTail: KeyValueChangeRecord_<K, V>|null = null;\n  private _additionsHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _additionsTail: KeyValueChangeRecord_<K, V>|null = null;\n  private _removalsHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _removalsTail: KeyValueChangeRecord_<K, V>|null = null;\n\n  get isDirty(): boolean {\n    return this._additionsHead !== null || this._changesHead !== null ||\n        this._removalsHead !== null;\n  }\n\n  forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._mapHead; record !== null; record = record._next) {\n      fn(record);\n    }\n  }\n\n  forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\n      fn(record);\n    }\n  }\n\n  forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._changesHead; record !== null; record = record._nextChanged) {\n      fn(record);\n    }\n  }\n\n  forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n      fn(record);\n    }\n  }\n\n  forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n      fn(record);\n    }\n  }\n\n  diff(map?: Map<any, any>|{[k: string]: any}|null): any {\n    if (!map) {\n      map = new Map();\n    } else if (!(map instanceof Map || isJsObject(map))) {\n      throw new Error(\n          `Error trying to diff '${stringify(map)}'. Only maps and objects are allowed`);\n    }\n\n    return this.check(map) ? this : null;\n  }\n\n  onDestroy() {}\n\n  /**\n   * Check the current state of the map vs the previous.\n   * The algorithm is optimised for when the keys do no change.\n   */\n  check(map: Map<any, any>|{[k: string]: any}): boolean {\n    this._reset();\n\n    let insertBefore = this._mapHead;\n    this._appendAfter = null;\n\n    this._forEach(map, (value: any, key: any) => {\n      if (insertBefore && insertBefore.key === key) {\n        this._maybeAddToChanges(insertBefore, value);\n        this._appendAfter = insertBefore;\n        insertBefore = insertBefore._next;\n      } else {\n        const record = this._getOrCreateRecordForKey(key, value);\n        insertBefore = this._insertBeforeOrAppend(insertBefore, record);\n      }\n    });\n\n    // Items remaining at the end of the list have been deleted\n    if (insertBefore) {\n      if (insertBefore._prev) {\n        insertBefore._prev._next = null;\n      }\n\n      this._removalsHead = insertBefore;\n\n      for (let record: KeyValueChangeRecord_<K, V>|null = insertBefore; record !== null;\n           record = record._nextRemoved) {\n        if (record === this._mapHead) {\n          this._mapHead = null;\n        }\n        this._records.delete(record.key);\n        record._nextRemoved = record._next;\n        record.previousValue = record.currentValue;\n        record.currentValue = null;\n        record._prev = null;\n        record._next = null;\n      }\n    }\n\n    // Make sure tails have no next records from previous runs\n    if (this._changesTail) this._changesTail._nextChanged = null;\n    if (this._additionsTail) this._additionsTail._nextAdded = null;\n\n    return this.isDirty;\n  }\n\n  /**\n   * Inserts a record before `before` or append at the end of the list when `before` is null.\n   *\n   * Notes:\n   * - This method appends at `this._appendAfter`,\n   * - This method updates `this._appendAfter`,\n   * - The return value is the new value for the insertion pointer.\n   */\n  private _insertBeforeOrAppend(\n      before: KeyValueChangeRecord_<K, V>|null,\n      record: KeyValueChangeRecord_<K, V>): KeyValueChangeRecord_<K, V>|null {\n    if (before) {\n      const prev = before._prev;\n      record._next = before;\n      record._prev = prev;\n      before._prev = record;\n      if (prev) {\n        prev._next = record;\n      }\n      if (before === this._mapHead) {\n        this._mapHead = record;\n      }\n\n      this._appendAfter = before;\n      return before;\n    }\n\n    if (this._appendAfter) {\n      this._appendAfter._next = record;\n      record._prev = this._appendAfter;\n    } else {\n      this._mapHead = record;\n    }\n\n    this._appendAfter = record;\n    return null;\n  }\n\n  private _getOrCreateRecordForKey(key: K, value: V): KeyValueChangeRecord_<K, V> {\n    if (this._records.has(key)) {\n      const record = this._records.get(key) !;\n      this._maybeAddToChanges(record, value);\n      const prev = record._prev;\n      const next = record._next;\n      if (prev) {\n        prev._next = next;\n      }\n      if (next) {\n        next._prev = prev;\n      }\n      record._next = null;\n      record._prev = null;\n\n      return record;\n    }\n\n    const record = new KeyValueChangeRecord_<K, V>(key);\n    this._records.set(key, record);\n    record.currentValue = value;\n    this._addToAdditions(record);\n    return record;\n  }\n\n  /** @internal */\n  _reset() {\n    if (this.isDirty) {\n      let record: KeyValueChangeRecord_<K, V>|null;\n      // let `_previousMapHead` contain the state of the map before the changes\n      this._previousMapHead = this._mapHead;\n      for (record = this._previousMapHead; record !== null; record = record._next) {\n        record._nextPrevious = record._next;\n      }\n\n      // Update `record.previousValue` with the value of the item before the changes\n      // We need to update all changed items (that's those which have been added and changed)\n      for (record = this._changesHead; record !== null; record = record._nextChanged) {\n        record.previousValue = record.currentValue;\n      }\n      for (record = this._additionsHead; record != null; record = record._nextAdded) {\n        record.previousValue = record.currentValue;\n      }\n\n      this._changesHead = this._changesTail = null;\n      this._additionsHead = this._additionsTail = null;\n      this._removalsHead = null;\n    }\n  }\n\n  // Add the record or a given key to the list of changes only when the value has actually changed\n  private _maybeAddToChanges(record: KeyValueChangeRecord_<K, V>, newValue: any): void {\n    if (!looseIdentical(newValue, record.currentValue)) {\n      record.previousValue = record.currentValue;\n      record.currentValue = newValue;\n      this._addToChanges(record);\n    }\n  }\n\n  private _addToAdditions(record: KeyValueChangeRecord_<K, V>) {\n    if (this._additionsHead === null) {\n      this._additionsHead = this._additionsTail = record;\n    } else {\n      this._additionsTail !._nextAdded = record;\n      this._additionsTail = record;\n    }\n  }\n\n  private _addToChanges(record: KeyValueChangeRecord_<K, V>) {\n    if (this._changesHead === null) {\n      this._changesHead = this._changesTail = record;\n    } else {\n      this._changesTail !._nextChanged = record;\n      this._changesTail = record;\n    }\n  }\n\n  /** @internal */\n  private _forEach<K, V>(obj: Map<K, V>|{[k: string]: V}, fn: (v: V, k: any) => void) {\n    if (obj instanceof Map) {\n      obj.forEach(fn);\n    } else {\n      Object.keys(obj).forEach(k => fn(obj[k], k));\n    }\n  }\n}\n\nclass KeyValueChangeRecord_<K, V> implements KeyValueChangeRecord<K, V> {\n  previousValue: V|null = null;\n  currentValue: V|null = null;\n\n  /** @internal */\n  _nextPrevious: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _next: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _prev: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _nextAdded: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _nextRemoved: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _nextChanged: KeyValueChangeRecord_<K, V>|null = null;\n\n  constructor(public key: K) {}\n}\n"]}