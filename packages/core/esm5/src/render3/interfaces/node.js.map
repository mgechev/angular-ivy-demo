{"version":3,"file":"node.js","sourceRoot":"","sources":["../../../../../../../packages/core/src/render3/interfaces/node.ts"],"names":[],"mappings":";;;;;;;;;;;;;IAiBE,YAAiB;IACjB,aAAkB;IAClB,OAAY;IACZ,UAAe;IACf,gBAAqB;IACrB,mBAAwB;IACxB,eAAoB;;;;;;IAQpB,wBAAuD;;IAGvD,iBAAgD;;IAGhD,iBAAgD;;IAGhD,sBAAoD;;IAGpD,oBAAkD;;IAGlD,+BAAgC;;;;;;IAQhC,8BAA4D;;;IAI5D,8BAA+B;IAC/B,mCAAiE;;;;;;;;;;IAYjE,eAAgB;;;;;;;IAQhB,aAAc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuYhB,WAAa,6BAA6B,GAAG,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StylingContext} from './styling';\nimport {LView, TView} from './view';\n\n\n/**\n * TNodeType corresponds to the TNode.type property. It contains information\n * on how to map a particular set of bits in TNode.flags to the node type.\n */\nexport const enum TNodeType {\n  Container = 0b000,\n  Projection = 0b001,\n  View = 0b010,\n  Element = 0b011,\n  ViewOrElement = 0b010,\n  ElementContainer = 0b100,\n  IcuContainer = 0b101,\n}\n\n/**\n * Corresponds to the TNode.flags property.\n */\nexport const enum TNodeFlags {\n  /** The number of directives on this node is encoded on the least significant bits */\n  DirectiveCountMask = 0b00000000000000000000111111111111,\n\n  /** This bit is set if the node is a component */\n  isComponent = 0b00000000000000000001000000000000,\n\n  /** This bit is set if the node has been projected */\n  isProjected = 0b00000000000000000010000000000000,\n\n  /** This bit is set if the node has any content queries */\n  hasContentQuery = 0b00000000000000000100000000000000,\n\n  /** This bit is set if the node has any directives that contain [class properties */\n  hasClassInput = 0b00000000000000001000000000000000,\n\n  /** The index of the first directive on this node is encoded on the most significant bits  */\n  DirectiveStartingIndexShift = 16,\n}\n\n/**\n * Corresponds to the TNode.providerIndexes property.\n */\nexport const enum TNodeProviderIndexes {\n  /** The index of the first provider on this node is encoded on the least significant bits */\n  ProvidersStartIndexMask = 0b00000000000000001111111111111111,\n\n  /** The count of view providers from the component on this node is encoded on the 16 most\n     significant bits */\n  CptViewProvidersCountShift = 16,\n  CptViewProvidersCountShifter = 0b00000000000000010000000000000000,\n}\n/**\n * A set of marker values to be used in the attributes arrays. Those markers indicate that some\n * items are not regular attributes and the processing should be adapted accordingly.\n */\nexport const enum AttributeMarker {\n  /**\n   * Marker indicates that the following 3 values in the attributes array are:\n   * namespaceUri, attributeName, attributeValue\n   * in that order.\n   */\n  NamespaceURI = 0,\n\n  /**\n   * This marker indicates that the following attribute names were extracted from bindings (ex.:\n   * [foo]=\"exp\") and / or event handlers (ex. (bar)=\"doSth()\").\n   * Taking the above bindings and outputs as an example an attributes array could look as follows:\n   * ['class', 'fade in', AttributeMarker.SelectOnly, 'foo', 'bar']\n   */\n  SelectOnly = 1\n}\n\n/**\n * A combination of:\n * - attribute names and values\n * - special markers acting as flags to alter attributes processing.\n */\nexport type TAttributes = (string | AttributeMarker)[];\n\n/**\n * Binding data (flyweight) for a particular node that is shared between all templates\n * of a specific type.\n *\n * If a property is:\n *    - PropertyAliases: that property's data was generated and this is it\n *    - Null: that property's data was already generated and nothing was found.\n *    - Undefined: that property's data has not yet been generated\n *\n * see: https://en.wikipedia.org/wiki/Flyweight_pattern for more on the Flyweight pattern\n */\nexport interface TNode {\n  /** The type of the TNode. See TNodeType. */\n  type: TNodeType;\n\n  /**\n   * Index of the TNode in TView.data and corresponding native element in LView.\n   *\n   * This is necessary to get from any TNode to its corresponding native element when\n   * traversing the node tree.\n   *\n   * If index is -1, this is a dynamically created container node or embedded view node.\n   */\n  index: number;\n\n  /**\n   * The index of the closest injector in this node's LView.\n   *\n   * If the index === -1, there is no injector on this node or any ancestor node in this view.\n   *\n   * If the index !== -1, it is the index of this node's injector OR the index of a parent injector\n   * in the same view. We pass the parent injector index down the node tree of a view so it's\n   * possible to find the parent injector without walking a potentially deep node tree. Injector\n   * indices are not set across view boundaries because there could be multiple component hosts.\n   *\n   * If tNode.injectorIndex === tNode.parent.injectorIndex, then the index belongs to a parent\n   * injector.\n   */\n  injectorIndex: number;\n\n  /**\n   * This number stores two values using its bits:\n   *\n   * - the number of directives on that node (first 12 bits)\n   * - the starting index of the node's directives in the directives array (last 20 bits).\n   *\n   * These two values are necessary so DI can effectively search the directives associated\n   * with a node without searching the whole directives array.\n   */\n  flags: TNodeFlags;\n\n  /**\n   * This number stores two values using its bits:\n   *\n   * - the index of the first provider on that node (first 16 bits)\n   * - the count of view providers from the component on this node (last 16 bits)\n   */\n  providerIndexes: TNodeProviderIndexes;\n\n  /** The tag name associated with this node. */\n  tagName: string|null;\n\n  /**\n   * Attributes associated with an element. We need to store attributes to support various use-cases\n   * (attribute injection, content projection with selectors, directives matching).\n   * Attributes are stored statically because reading them from the DOM would be way too slow for\n   * content projection and queries.\n   *\n   * Since attrs will always be calculated first, they will never need to be marked undefined by\n   * other instructions.\n   *\n   * For regular attributes a name of an attribute and its value alternate in the array.\n   * e.g. ['role', 'checkbox']\n   * This array can contain flags that will indicate \"special attributes\" (attributes with\n   * namespaces, attributes extracted from bindings and outputs).\n   */\n  attrs: TAttributes|null;\n\n  /**\n   * A set of local names under which a given element is exported in a template and\n   * visible to queries. An entry in this array can be created for different reasons:\n   * - an element itself is referenced, ex.: `<div #foo>`\n   * - a component is referenced, ex.: `<my-cmpt #foo>`\n   * - a directive is referenced, ex.: `<my-cmpt #foo=\"directiveExportAs\">`.\n   *\n   * A given element might have different local names and those names can be associated\n   * with a directive. We store local names at even indexes while odd indexes are reserved\n   * for directive index in a view (or `-1` if there is no associated directive).\n   *\n   * Some examples:\n   * - `<div #foo>` => `[\"foo\", -1]`\n   * - `<my-cmpt #foo>` => `[\"foo\", myCmptIdx]`\n   * - `<my-cmpt #foo #bar=\"directiveExportAs\">` => `[\"foo\", myCmptIdx, \"bar\", directiveIdx]`\n   * - `<div #foo #bar=\"directiveExportAs\">` => `[\"foo\", -1, \"bar\", directiveIdx]`\n   */\n  localNames: (string|number)[]|null;\n\n  /** Information about input properties that need to be set once from attribute data. */\n  initialInputs: InitialInputData|null|undefined;\n\n  /**\n   * Input data for all directives on this node.\n   *\n   * - `undefined` means that the prop has not been initialized yet,\n   * - `null` means that the prop has been initialized but no inputs have been found.\n   */\n  inputs: PropertyAliases|null|undefined;\n\n  /**\n   * Output data for all directives on this node.\n   *\n   * - `undefined` means that the prop has not been initialized yet,\n   * - `null` means that the prop has been initialized but no outputs have been found.\n   */\n  outputs: PropertyAliases|null|undefined;\n\n  /**\n   * The TView or TViews attached to this node.\n   *\n   * If this TNode corresponds to an LContainer with inline views, the container will\n   * need to store separate static data for each of its view blocks (TView[]). Otherwise,\n   * nodes in inline views with the same index as nodes in their parent views will overwrite\n   * each other, as they are in the same template.\n   *\n   * Each index in this array corresponds to the static data for a certain\n   * view. So if you had V(0) and V(1) in a container, you might have:\n   *\n   * [\n   *   [{tagName: 'div', attrs: ...}, null],     // V(0) TView\n   *   [{tagName: 'button', attrs ...}, null]    // V(1) TView\n   *\n   * If this TNode corresponds to an LContainer with a template (e.g. structural\n   * directive), the template's TView will be stored here.\n   *\n   * If this TNode corresponds to an element, tViews will be null .\n   */\n  tViews: TView|TView[]|null;\n\n  /**\n   * The next sibling node. Necessary so we can propagate through the root nodes of a view\n   * to insert them or remove them from the DOM.\n   */\n  next: TNode|null;\n\n  /**\n   * First child of the current node.\n   *\n   * For component nodes, the child will always be a ContentChild (in same view).\n   * For embedded view nodes, the child will be in their child view.\n   */\n  child: TNode|null;\n\n  /**\n   * Parent node (in the same view only).\n   *\n   * We need a reference to a node's parent so we can append the node to its parent's native\n   * element at the appropriate time.\n   *\n   * If the parent would be in a different view (e.g. component host), this property will be null.\n   * It's important that we don't try to cross component boundaries when retrieving the parent\n   * because the parent will change (e.g. index, attrs) depending on where the component was\n   * used (and thus shouldn't be stored on TNode). In these cases, we retrieve the parent through\n   * LView.node instead (which will be instance-specific).\n   *\n   * If this is an inline view node (V), the parent will be its container.\n   */\n  parent: TElementNode|TContainerNode|null;\n\n  /**\n   * If this node is part of an i18n block, it indicates whether this node is part of the DOM.\n   * If this node is not part of an i18n block, this field is null.\n   */\n  detached: boolean|null;\n\n  stylingTemplate: StylingContext|null;\n  /**\n   * List of projected TNodes for a given component host element OR index into the said nodes.\n   *\n   * For easier discussion assume this example:\n   * `<parent>`'s view definition:\n   * ```\n   * <child id=\"c1\">content1</child>\n   * <child id=\"c2\"><span>content2</span></child>\n   * ```\n   * `<child>`'s view definition:\n   * ```\n   * <ng-content id=\"cont1\"></ng-content>\n   * ```\n   *\n   * If `Array.isArray(projection)` then `TNode` is a host element:\n   * - `projection` stores the content nodes which are to be projected.\n   *    - The nodes represent categories defined by the selector: For example:\n   *      `<ng-content/><ng-content select=\"abc\"/>` would represent the heads for `<ng-content/>`\n   *      and `<ng-content select=\"abc\"/>` respectively.\n   *    - The nodes we store in `projection` are heads only, we used `.next` to get their\n   *      siblings.\n   *    - The nodes `.next` is sorted/rewritten as part of the projection setup.\n   *    - `projection` size is equal to the number of projections `<ng-content>`. The size of\n   *      `c1` will be `1` because `<child>` has only one `<ng-content>`.\n   * - we store `projection` with the host (`c1`, `c2`) rather than the `<ng-content>` (`cont1`)\n   *   because the same component (`<child>`) can be used in multiple locations (`c1`, `c2`) and as\n   *   a result have different set of nodes to project.\n   * - without `projection` it would be difficult to efficiently traverse nodes to be projected.\n   *\n   * If `typeof projection == 'number'` then `TNode` is a `<ng-content>` element:\n   * - `projection` is an index of the host's `projection`Nodes.\n   *   - This would return the first head node to project:\n   *     `getHost(currentTNode).projection[currentTNode.projection]`.\n   * - When projecting nodes the parent node retrieved may be a `<ng-content>` node, in which case\n   *   the process is recursive in nature (not implementation).\n   */\n  projection: (TNode|null)[]|number|null;\n}\n\n/** Static data for an element  */\nexport interface TElementNode extends TNode {\n  /** Index in the data[] array */\n  index: number;\n  child: TElementNode|TTextNode|TElementContainerNode|TContainerNode|TProjectionNode|null;\n  /**\n   * Element nodes will have parents unless they are the first node of a component or\n   * embedded view (which means their parent is in a different view and must be\n   * retrieved using viewData[HOST_NODE]).\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n\n  /**\n   * If this is a component TNode with projection, this will be an array of projected\n   * TNodes (see TNode.projection for more info). If it's a regular element node or a\n   * component without projection, it will be null.\n   */\n  projection: (TNode|null)[]|null;\n}\n\n/** Static data for a text node */\nexport interface TTextNode extends TNode {\n  /** Index in the data[] array */\n  index: number;\n  child: null;\n  /**\n   * Text nodes will have parents unless they are the first node of a component or\n   * embedded view (which means their parent is in a different view and must be\n   * retrieved using LView.node).\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n}\n\n/** Static data for an LContainer */\nexport interface TContainerNode extends TNode {\n  /**\n   * Index in the data[] array.\n   *\n   * If it's -1, this is a dynamically created container node that isn't stored in\n   * data[] (e.g. when you inject ViewContainerRef) .\n   */\n  index: number;\n  child: null;\n\n  /**\n   * Container nodes will have parents unless:\n   *\n   * - They are the first node of a component or embedded view\n   * - They are dynamically created\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: TView|TView[]|null;\n  projection: null;\n}\n\n/** Static data for an <ng-container> */\nexport interface TElementContainerNode extends TNode {\n  /** Index in the LView[] array. */\n  index: number;\n  child: TElementNode|TTextNode|TContainerNode|TElementContainerNode|TProjectionNode|null;\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n}\n\n/** Static data for an ICU expression */\nexport interface TIcuContainerNode extends TNode {\n  /** Index in the LView[] array. */\n  index: number;\n  child: TElementNode|TTextNode|null;\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n  /**\n   * Indicates the current active case for an ICU expression.\n   * It is null when there is no active case.\n   */\n  activeCaseIndex: number|null;\n}\n\n/** Static data for a view  */\nexport interface TViewNode extends TNode {\n  /** If -1, it's a dynamically created view. Otherwise, it is the view block ID. */\n  index: number;\n  child: TElementNode|TTextNode|TElementContainerNode|TContainerNode|TProjectionNode|null;\n  parent: TContainerNode|null;\n  tViews: null;\n  projection: null;\n}\n\n/** Static data for an LProjectionNode  */\nexport interface TProjectionNode extends TNode {\n  /** Index in the data[] array */\n  child: null;\n  /**\n   * Projection nodes will have parents unless they are the first node of a component\n   * or embedded view (which means their parent is in a different view and must be\n   * retrieved using LView.node).\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n\n  /** Index of the projection node. (See TNode.projection for more info.) */\n  projection: number;\n}\n\n/**\n * This mapping is necessary so we can set input properties and output listeners\n * properly at runtime when property names are minified or aliased.\n *\n * Key: unminified / public input or output name\n * Value: array containing minified / internal name and related directive index\n *\n * The value must be an array to support inputs and outputs with the same name\n * on the same node.\n */\nexport type PropertyAliases = {\n  // This uses an object map because using the Map type would be too slow\n  [key: string]: PropertyAliasValue\n};\n\n/**\n * Store the runtime input or output names for all the directives.\n *\n * - Even indices: directive index\n * - Odd indices: minified / internal name\n *\n * e.g. [0, 'change-minified']\n */\nexport type PropertyAliasValue = (number | string)[];\n\n\n/**\n * This array contains information about input properties that\n * need to be set once from attribute data. It's ordered by\n * directive index (relative to element) so it's simple to\n * look up a specific directive's initial input data.\n *\n * Within each sub-array:\n *\n * Even indices: minified/internal input name\n * Odd indices: initial value\n *\n * If a directive on a node does not have any input properties\n * that should be set from attributes, its index is set to null\n * to avoid a sparse array.\n *\n * e.g. [null, ['role-min', 'button']]\n */\nexport type InitialInputData = (InitialInputs | null)[];\n\n/**\n * Used by InitialInputData to store input properties\n * that should be set once from attributes.\n *\n * Even indices: minified/internal input name\n * Odd indices: initial value\n *\n * e.g. ['role-min', 'button']\n */\nexport type InitialInputs = string[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n\n/**\n * Type representing a set of TNodes that can have local refs (`#foo`) placed on them.\n */\nexport type TNodeWithLocalRefs = TContainerNode | TElementNode | TElementContainerNode;\n\n/**\n * Type for a function that extracts a value for a local refs.\n * Example:\n * - `<div #nativeDivEl>` - `nativeDivEl` should point to the native `<div>` element;\n * - `<ng-template #tplRef>` - `tplRef` should point to the `TemplateRef` instance;\n */\nexport type LocalRefExtractor = (tNode: TNodeWithLocalRefs, currentView: LView) => any;\n"]}