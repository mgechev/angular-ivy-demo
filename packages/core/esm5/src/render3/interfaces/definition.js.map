{"version":3,"file":"definition.js","sourceRoot":"","sources":["../../../../../../../packages/core/src/render3/interfaces/definition.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;IAmCE,SAAa;;IAGb,SAAa;;;;;;;;;;;;;;;;;;;;;;;IAesB,eAAmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqSxD,WAAa,6BAA6B,GAAG,CAAC,CAAC;;;IAG7C,cAAiB","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ViewEncapsulation} from '../../core';\nimport {Type} from '../../type';\nimport {CssSelectorList} from './projection';\n\n\n/**\n * Definition of what a template rendering function should look like for a component.\n */\nexport type ComponentTemplate<T> = {\n  (rf: RenderFlags, ctx: T): void; ngPrivateData?: never;\n};\n\n/**\n * Definition of what a query function should look like.\n */\nexport type ComponentQuery<T> = ComponentTemplate<T>;\n\n/**\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\n * should be executed.\n *\n * Typically, a template runs both the creation block and the update block on initialization and\n * subsequent runs only execute the update block. However, dynamically created views require that\n * the creation block be executed separately from the update block (for backwards compat).\n */\nexport const enum RenderFlags {\n  /* Whether to run the creation block (e.g. create elements and directives) */\n  Create = 0b01,\n\n  /* Whether to run the update block (e.g. refresh bindings) */\n  Update = 0b10\n}\n\n/**\n * A subclass of `Type` which has a static `ngComponentDef`:`ComponentDef` field making it\n * consumable for rendering.\n */\nexport interface ComponentType<T> extends Type<T> { ngComponentDef: never; }\n\n/**\n * A subclass of `Type` which has a static `ngDirectiveDef`:`DirectiveDef` field making it\n * consumable for rendering.\n */\nexport interface DirectiveType<T> extends Type<T> { ngDirectiveDef: never; }\n\nexport const enum DirectiveDefFlags {ContentQuery = 0b10}\n\n/**\n * A subclass of `Type` which has a static `ngPipeDef`:`PipeDef` field making it\n * consumable for rendering.\n */\nexport interface PipeType<T> extends Type<T> { ngPipeDef: never; }\n\nexport type DirectiveDefWithMeta<\n    T, Selector extends string, ExportAs extends string, InputMap extends{[key: string]: string},\n    OutputMap extends{[key: string]: string}, QueryFields extends string[]> = DirectiveDef<T>;\n\n/**\n * Runtime information for classes that are inherited by components or directives\n * that aren't defined as components or directives.\n *\n * This is an internal data structure used by the render to determine what inputs\n * and outputs should be inherited.\n *\n * See: {@link defineBase}\n */\nexport interface BaseDef<T> {\n  /**\n   * A dictionary mapping the inputs' minified property names to their public API names, which\n   * are their aliases if any, or their original unminified property names\n   * (as in `@Input('alias') propertyName: any;`).\n   */\n  readonly inputs: {[P in keyof T]: string};\n\n  /**\n   * @deprecated This is only here because `NgOnChanges` incorrectly uses declared name instead of\n   * public or minified name.\n   */\n  readonly declaredInputs: {[P in keyof T]: P};\n\n  /**\n   * A dictionary mapping the outputs' minified property names to their public API names, which\n   * are their aliases if any, or their original unminified property names\n   * (as in `@Output('alias') propertyName: any;`).\n   */\n  readonly outputs: {[P in keyof T]: P};\n}\n\n/**\n * Runtime link information for Directives.\n *\n * This is internal data structure used by the render to link\n * directives into templates.\n *\n * NOTE: Always use `defineDirective` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * @param Selector type metadata specifying the selector of the directive or component\n *\n * See: {@link defineDirective}\n */\nexport interface DirectiveDef<T> extends BaseDef<T> {\n  /** Token representing the directive. Used by DI. */\n  type: Type<T>;\n\n  /** Function that resolves providers and publishes them into the DI system. */\n  providersResolver: ((def: DirectiveDef<T>) => void)|null;\n\n  /** The selectors that will be used to match nodes to this directive. */\n  readonly selectors: CssSelectorList;\n\n  /**\n   * Name under which the directive is exported (for use with local references in template)\n   */\n  readonly exportAs: string|null;\n\n  /**\n   * Factory function used to create a new directive instance.\n   */\n  factory: (t: Type<T>|null) => T;\n\n  /**\n   * Function to create instances of content queries associated with a given directive.\n   */\n  contentQueries: ((directiveIndex: number) => void)|null;\n\n  /** Refreshes content queries associated with directives in a given view */\n  contentQueriesRefresh: ((directiveIndex: number, queryIndex: number) => void)|null;\n\n  /** Refreshes host bindings on the associated directive. */\n  hostBindings: HostBindingsFunction<T>|null;\n\n  /**\n   * Static attributes to set on host element.\n   *\n   * Even indices: attribute name\n   * Odd indices: attribute value\n   */\n  readonly attributes: string[]|null;\n\n  /* The following are lifecycle hooks for this component */\n  onInit: (() => void)|null;\n  doCheck: (() => void)|null;\n  afterContentInit: (() => void)|null;\n  afterContentChecked: (() => void)|null;\n  afterViewInit: (() => void)|null;\n  afterViewChecked: (() => void)|null;\n  onDestroy: (() => void)|null;\n\n  /**\n   * The features applied to this directive\n   */\n  readonly features: DirectiveDefFeature[]|null;\n}\n\nexport type ComponentDefWithMeta<\n    T, Selector extends String, ExportAs extends string, InputMap extends{[key: string]: string},\n    OutputMap extends{[key: string]: string}, QueryFields extends string[]> = ComponentDef<T>;\n\n/**\n * Runtime link information for Components.\n *\n * This is internal data structure used by the render to link\n * components into templates.\n *\n * NOTE: Always use `defineComponent` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link defineComponent}\n */\nexport interface ComponentDef<T> extends DirectiveDef<T> {\n  /**\n   * Runtime unique component ID.\n   */\n  readonly id: string;\n\n  /**\n   * The View template of the component.\n   */\n  readonly template: ComponentTemplate<T>;\n\n  /**\n   * A set of styles that the component needs to be present for component to render correctly.\n   */\n  readonly styles: string[];\n\n  /**\n   * The number of nodes, local refs, and pipes in this component template.\n   *\n   * Used to calculate the length of the component's LView array, so we\n   * can pre-fill the array and set the binding start index.\n   */\n  // TODO(kara): remove queries from this count\n  readonly consts: number;\n\n  /**\n   * The number of bindings in this component template (including pure fn bindings).\n   *\n   * Used to calculate the length of the component's LView array, so we\n   * can pre-fill the array and set the host binding start index.\n   */\n  readonly vars: number;\n\n  /**\n   * Query-related instructions for a component.\n   */\n  viewQuery: ComponentQuery<T>|null;\n\n  /**\n   * The view encapsulation type, which determines how styles are applied to\n   * DOM elements. One of\n   * - `Emulated` (default): Emulate native scoping of styles.\n   * - `Native`: Use the native encapsulation mechanism of the renderer.\n   * - `ShadowDom`: Use modern [ShadowDOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n   *   create a ShadowRoot for component's host element.\n   * - `None`: Do not provide any template or style encapsulation.\n   */\n  readonly encapsulation: ViewEncapsulation;\n\n  /**\n   * Defines arbitrary developer-defined data to be stored on a renderer instance.\n   * This is useful for renderers that delegate to other renderers.\n   */\n  readonly data: {[kind: string]: any};\n\n  /** Whether or not this component's ChangeDetectionStrategy is OnPush */\n  readonly onPush: boolean;\n\n  /**\n\n   * Registry of directives and components that may be found in this view.\n   *\n   * The property is either an array of `DirectiveDef`s or a function which returns the array of\n   * `DirectiveDef`s. The function is necessary to be able to support forward declarations.\n   */\n  directiveDefs: DirectiveDefListOrFactory|null;\n\n  /**\n   * Registry of pipes that may be found in this view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   */\n  pipeDefs: PipeDefListOrFactory|null;\n\n  /**\n   * Used to store the result of `noSideEffects` function so that it is not removed by closure\n   * compiler. The property should never be read.\n   */\n  readonly _?: never;\n}\n\n/**\n * Runtime link information for Pipes.\n *\n * This is internal data structure used by the renderer to link\n * pipes into templates.\n *\n * NOTE: Always use `definePipe` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link definePipe}\n */\nexport interface PipeDef<T> {\n  /**\n   * Pipe name.\n   *\n   * Used to resolve pipe in templates.\n   */\n  readonly name: string;\n\n  /**\n   * Factory function used to create a new pipe instance.\n   */\n  factory: (t: Type<T>|null) => T;\n\n  /**\n   * Whether or not the pipe is pure.\n   *\n   * Pure pipes result only depends on the pipe input and not on internal\n   * state of the pipe.\n   */\n  readonly pure: boolean;\n\n  /* The following are lifecycle hooks for this pipe */\n  onDestroy: (() => void)|null;\n}\n\nexport type PipeDefWithMeta<T, Name extends string> = PipeDef<T>;\n\nexport interface DirectiveDefFeature {\n  <T>(directiveDef: DirectiveDef<T>): void;\n  ngInherit?: true;\n}\n\nexport interface ComponentDefFeature {\n  <T>(componentDef: ComponentDef<T>): void;\n  ngInherit?: true;\n}\n\n\n/**\n * Type used for directiveDefs on component definition.\n *\n * The function is necessary to be able to support forward declarations.\n */\nexport type DirectiveDefListOrFactory = (() => DirectiveDefList) | DirectiveDefList;\n\nexport type DirectiveDefList = (DirectiveDef<any>| ComponentDef<any>)[];\n\nexport type DirectiveTypesOrFactory = (() => DirectiveTypeList) | DirectiveTypeList;\n\nexport type DirectiveTypeList =\n    (DirectiveDef<any>| ComponentDef<any>|\n     Type<any>/* Type as workaround for: Microsoft/TypeScript/issues/4881 */)[];\n\nexport type HostBindingsFunction<T> = (rf: RenderFlags, ctx: T, elementIndex: number) => void;\n\n/**\n * Type used for PipeDefs on component definition.\n *\n * The function is necessary to be able to support forward declarations.\n */\nexport type PipeDefListOrFactory = (() => PipeDefList) | PipeDefList;\n\nexport type PipeDefList = PipeDef<any>[];\n\nexport type PipeTypesOrFactory = (() => DirectiveTypeList) | DirectiveTypeList;\n\nexport type PipeTypeList =\n    (PipeDef<any>| Type<any>/* Type as workaround for: Microsoft/TypeScript/issues/4881 */)[];\n\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n\nexport const enum InitialStylingFlags {\n  VALUES_MODE = 0b1,\n}\n"]}