{"version":3,"file":"state.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/state.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from './assert';\nimport {executeHooks} from './hooks';\nimport {ComponentDef, DirectiveDef} from './interfaces/definition';\nimport {TElementNode, TNode, TNodeFlags, TViewNode} from './interfaces/node';\nimport {LQueries} from './interfaces/query';\nimport {BINDING_INDEX, CONTEXT, DECLARATION_VIEW, FLAGS, HOST_NODE, LView, LViewFlags, OpaqueViewState, QUERIES, TVIEW} from './interfaces/view';\nimport {isContentQueryHost} from './util';\n\n\n\n/**\n * Store the element depth count. This is used to identify the root elements of the template\n * so that we can than attach `LView` to only those elements.\n */\nlet elementDepthCount !: number;\n\nexport function getElementDepthCount() {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return elementDepthCount;\n}\n\nexport function increaseElementDepthCount() {\n  elementDepthCount++;\n}\n\nexport function decreaseElementDepthCount() {\n  elementDepthCount--;\n}\n\nlet currentDirectiveDef: DirectiveDef<any>|ComponentDef<any>|null = null;\n\nexport function getCurrentDirectiveDef(): DirectiveDef<any>|ComponentDef<any>|null {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return currentDirectiveDef;\n}\n\nexport function setCurrentDirectiveDef(def: DirectiveDef<any>| ComponentDef<any>| null): void {\n  currentDirectiveDef = def;\n}\n\n/**\n * Stores whether directives should be matched to elements.\n *\n * When template contains `ngNonBindable` than we need to prevent the runtime form matching\n * directives on children of that element.\n *\n * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n * </div>\n * ```\n */\nlet bindingsEnabled !: boolean;\n\nexport function getBindingsEnabled(): boolean {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return bindingsEnabled;\n}\n\n\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- disabledBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- enableBindings() -->\n * </div>\n * ```\n */\nexport function enableBindings(): void {\n  bindingsEnabled = true;\n}\n\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- disabledBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- enableBindings() -->\n * </div>\n * ```\n */\nexport function disableBindings(): void {\n  bindingsEnabled = false;\n}\n\nexport function getLView(): LView {\n  return lView;\n}\n\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n */\nexport function restoreView(viewToRestore: OpaqueViewState) {\n  contextLView = viewToRestore as any as LView;\n}\n\n/** Used to set the parent property when nodes are created and track query results. */\nlet previousOrParentTNode: TNode;\n\nexport function getPreviousOrParentTNode(): TNode {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return previousOrParentTNode;\n}\n\nexport function setPreviousOrParentTNode(tNode: TNode) {\n  previousOrParentTNode = tNode;\n}\n\nexport function setTNodeAndViewData(tNode: TNode, view: LView) {\n  previousOrParentTNode = tNode;\n  lView = view;\n}\n\n/**\n * If `isParent` is:\n *  - `true`: then `previousOrParentTNode` points to a parent node.\n *  - `false`: then `previousOrParentTNode` points to previous node (sibling).\n */\nlet isParent: boolean;\n\nexport function getIsParent(): boolean {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return isParent;\n}\n\nexport function setIsParent(value: boolean): void {\n  isParent = value;\n}\n\n/**\n * Query instructions can ask for \"current queries\" in 2 different cases:\n * - when creating view queries (at the root of a component view, before any node is created - in\n * this case currentQueries points to view queries)\n * - when creating content queries (i.e. this previousOrParentTNode points to a node on which we\n * create content queries).\n */\nexport function getOrCreateCurrentQueries(\n    QueryType: {new (parent: null, shallow: null, deep: null): LQueries}): LQueries {\n  const lView = getLView();\n  let currentQueries = lView[QUERIES];\n  // if this is the first content query on a node, any existing LQueries needs to be cloned\n  // in subsequent template passes, the cloning occurs before directive instantiation.\n  if (previousOrParentTNode && previousOrParentTNode !== lView[HOST_NODE] &&\n      !isContentQueryHost(previousOrParentTNode)) {\n    currentQueries && (currentQueries = lView[QUERIES] = currentQueries.clone());\n    previousOrParentTNode.flags |= TNodeFlags.hasContentQuery;\n  }\n\n  return currentQueries || (lView[QUERIES] = new QueryType(null, null, null));\n}\n\n/**\n * This property gets set before entering a template.\n */\nlet creationMode: boolean;\n\nexport function getCreationMode(): boolean {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return creationMode;\n}\n\n/**\n * State of the current view being processed.\n *\n * An array of nodes (text, element, container, etc), pipes, their bindings, and\n * any local variables that need to be stored between invocations.\n */\nlet lView: LView;\n\n/**\n * The last viewData retrieved by nextContext().\n * Allows building nextContext() and reference() calls.\n *\n * e.g. const inner = x().$implicit; const outer = x().$implicit;\n */\nlet contextLView: LView = null !;\n\nexport function getContextLView(): LView {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return contextLView;\n}\n\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n */\nlet checkNoChangesMode = false;\n\nexport function getCheckNoChangesMode(): boolean {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return checkNoChangesMode;\n}\n\nexport function setCheckNoChangesMode(mode: boolean): void {\n  checkNoChangesMode = mode;\n}\n\n/** Whether or not this is the first time the current view has been processed. */\nlet firstTemplatePass = true;\n\nexport function getFirstTemplatePass(): boolean {\n  return firstTemplatePass;\n}\n\nexport function setFirstTemplatePass(value: boolean): void {\n  firstTemplatePass = value;\n}\n\n/**\n * The root index from which pure function instructions should calculate their binding\n * indices. In component views, this is TView.bindingStartIndex. In a host binding\n * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.\n */\nlet bindingRootIndex: number = -1;\n\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nexport function getBindingRoot() {\n  return bindingRootIndex;\n}\n\nexport function setBindingRoot(value: number) {\n  bindingRootIndex = value;\n}\n\n/**\n * Swap the current state with a new state.\n *\n * For performance reasons we store the state in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the state for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New state to become active\n * @param host Element to which the View is a child of\n * @returns the previous state;\n */\nexport function enterView(newView: LView, hostTNode: TElementNode | TViewNode | null): LView {\n  const oldView = lView;\n  if (newView) {\n    const tView = newView[TVIEW];\n\n    creationMode = (newView[FLAGS] & LViewFlags.CreationMode) === LViewFlags.CreationMode;\n    firstTemplatePass = tView.firstTemplatePass;\n    bindingRootIndex = tView.bindingStartIndex;\n  }\n\n  previousOrParentTNode = hostTNode !;\n  isParent = true;\n\n  lView = contextLView = newView;\n  return oldView;\n}\n\nexport function nextContextImpl<T = any>(level: number = 1): T {\n  contextLView = walkUpViews(level, contextLView !);\n  return contextLView[CONTEXT] as T;\n}\n\nfunction walkUpViews(nestingLevel: number, currentView: LView): LView {\n  while (nestingLevel > 0) {\n    ngDevMode && assertDefined(\n                     currentView[DECLARATION_VIEW],\n                     'Declaration view should be defined if nesting level is greater than 0.');\n    currentView = currentView[DECLARATION_VIEW] !;\n    nestingLevel--;\n  }\n  return currentView;\n}\n\n/**\n * Resets the application state.\n */\nexport function resetComponentState() {\n  isParent = false;\n  previousOrParentTNode = null !;\n  elementDepthCount = 0;\n  bindingsEnabled = true;\n}\n\n/**\n * Used in lieu of enterView to make it clear when we are exiting a child view. This makes\n * the direction of traversal (up or down the view tree) a bit clearer.\n *\n * @param newView New state to become active\n * @param creationOnly An optional boolean to indicate that the view was processed in creation mode\n * only, i.e. the first update will be done later. Only possible for dynamically created views.\n */\nexport function leaveView(newView: LView, creationOnly?: boolean): void {\n  const tView = lView[TVIEW];\n  if (!creationOnly) {\n    if (!checkNoChangesMode) {\n      executeHooks(lView, tView.viewHooks, tView.viewCheckHooks, creationMode);\n    }\n    // Views are clean and in update mode after being checked, so these bits are cleared\n    lView[FLAGS] &= ~(LViewFlags.CreationMode | LViewFlags.Dirty);\n  }\n  lView[FLAGS] |= LViewFlags.RunInit;\n  lView[BINDING_INDEX] = tView.bindingStartIndex;\n  enterView(newView, null);\n}\n"]}