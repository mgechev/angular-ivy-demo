{"version":3,"file":"pure_function.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/pure_function.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {bindingUpdated, bindingUpdated2, bindingUpdated3, bindingUpdated4, getBinding, updateBinding} from './bindings';\nimport {getBindingRoot, getCreationMode, getLView} from './state';\n\n\n\n/**\n * Bindings for pure functions are stored after regular bindings.\n *\n * |------consts------|---------vars---------|                 |----- hostVars (dir1) ------|\n * ------------------------------------------------------------------------------------------\n * | nodes/refs/pipes | bindings | fn slots  | injector | dir1 | host bindings | host slots |\n * ------------------------------------------------------------------------------------------\n *                    ^                      ^\n *      TView.bindingStartIndex      TView.expandoStartIndex\n *\n * Pure function instructions are given an offset from the binding root. Adding the offset to the\n * binding root gives the first index where the bindings are stored. In component views, the binding\n * root is the bindingStartIndex. In host bindings, the binding root is the expandoStartIndex +\n * any directive instances + any hostVars in directives evaluated before it.\n *\n * See VIEW_DATA.md for more information about host binding resolution.\n */\n\n/**\n * If the value hasn't been saved, calls the pure function to store and return the\n * value. If it has been saved, returns the saved value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns a value\n * @param thisArg Optional calling context of pureFn\n * @returns value\n */\nexport function pureFunction0<T>(slotOffset: number, pureFn: () => T, thisArg?: any): T {\n  // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  return getCreationMode() ?\n      updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) :\n      getBinding(lView, bindingIndex);\n}\n\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction1(\n    slotOffset: number, pureFn: (v: any) => any, exp: any, thisArg?: any): any {\n  // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\n  const lView = getLView();\n  const bindingIndex = getBindingRoot() + slotOffset;\n  return bindingUpdated(lView, bindingIndex, exp) ?\n      updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) :\n      getBinding(lView, bindingIndex + 1);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction2(\n    slotOffset: number, pureFn: (v1: any, v2: any) => any, exp1: any, exp2: any,\n    thisArg?: any): any {\n  // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ?\n      updateBinding(\n          lView, bindingIndex + 2,\n          thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) :\n      getBinding(lView, bindingIndex + 2);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction3(\n    slotOffset: number, pureFn: (v1: any, v2: any, v3: any) => any, exp1: any, exp2: any, exp3: any,\n    thisArg?: any): any {\n  // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ?\n      updateBinding(\n          lView, bindingIndex + 3,\n          thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) :\n      getBinding(lView, bindingIndex + 3);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction4(\n    slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any) => any, exp1: any, exp2: any,\n    exp3: any, exp4: any, thisArg?: any): any {\n  // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ?\n      updateBinding(\n          lView, bindingIndex + 4,\n          thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) :\n      getBinding(lView, bindingIndex + 4);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction5(\n    slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any) => any, exp1: any,\n    exp2: any, exp3: any, exp4: any, exp5: any, thisArg?: any): any {\n  // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ?\n      updateBinding(\n          lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) :\n                                             pureFn(exp1, exp2, exp3, exp4, exp5)) :\n      getBinding(lView, bindingIndex + 5);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction6(\n    slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any) => any,\n    exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, thisArg?: any): any {\n  // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ?\n      updateBinding(\n          lView, bindingIndex + 6, thisArg ?\n              pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) :\n              pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) :\n      getBinding(lView, bindingIndex + 6);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction7(\n    slotOffset: number,\n    pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any) => any, exp1: any,\n    exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, exp7: any, thisArg?: any): any {\n  // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ?\n      updateBinding(\n          lView, bindingIndex + 7, thisArg ?\n              pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) :\n              pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) :\n      getBinding(lView, bindingIndex + 7);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param exp8\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction8(\n    slotOffset: number,\n    pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any) => any,\n    exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, exp7: any, exp8: any,\n    thisArg?: any): any {\n  // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ?\n      updateBinding(\n          lView, bindingIndex + 8, thisArg ?\n              pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) :\n              pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) :\n      getBinding(lView, bindingIndex + 8);\n}\n\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunctionV(\n    slotOffset: number, pureFn: (...v: any[]) => any, exps: any[], thisArg?: any): any {\n  // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\n  let bindingIndex = getBindingRoot() + slotOffset;\n  let different = false;\n  const lView = getLView();\n  for (let i = 0; i < exps.length; i++) {\n    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);\n  }\n  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) :\n                     getBinding(lView, bindingIndex);\n}\n"]}