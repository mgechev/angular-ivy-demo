{"version":3,"file":"metadata.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/metadata.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,MAAM,UAAU,gBAAgB,CAC5B,IAAe,EAAE,UAAwB,EAAE,cAA4B,EACvE,cAA6C;;;IAC/C,IAAM,KAAK,qBAAG,IAAwB,EAAC;IACvC,IAAI,UAAU,KAAK,IAAI,EAAE;QACvB,IAAI,KAAK,CAAC,UAAU,KAAK,SAAS,EAAE;YAClC,CAAA,KAAA,KAAK,CAAC,UAAU,CAAA,CAAC,IAAI,WAAI,UAAU,EAAE;SACtC;aAAM;YACL,KAAK,CAAC,UAAU,GAAG,UAAU,CAAC;SAC/B;KACF;IACD,IAAI,cAAc,KAAK,IAAI,EAAE;;;;QAI3B,KAAK,CAAC,cAAc,GAAG,cAAc,CAAC;KACvC;IACD,IAAI,cAAc,KAAK,IAAI,EAAE;;;;;QAK3B,IAAI,KAAK,CAAC,cAAc,KAAK,SAAS,EAAE;YACtC,KAAK,CAAC,cAAc,wBAAO,KAAK,CAAC,cAAc,EAAK,cAAc,CAAC,CAAC;SACrE;aAAM;YACL,KAAK,CAAC,cAAc,GAAG,cAAc,CAAC;SACvC;KACF;CACF","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\n\ninterface TypeWithMetadata extends Type<any> {\n  decorators?: any[];\n  ctorParameters?: any[];\n  propDecorators?: {[field: string]: any};\n}\n\n/**\n * Adds decorator, constructor, and property metadata to a given type via static metadata fields\n * on the type.\n *\n * These metadata fields can later be read with Angular's `ReflectionCapabilities` API.\n *\n * Calls to `setClassMetadata` can be marked as pure, resulting in the metadata assignments being\n * tree-shaken away during production builds.\n */\nexport function setClassMetadata(\n    type: Type<any>, decorators: any[] | null, ctorParameters: any[] | null,\n    propDecorators: {[field: string]: any} | null): void {\n  const clazz = type as TypeWithMetadata;\n  if (decorators !== null) {\n    if (clazz.decorators !== undefined) {\n      clazz.decorators.push(...decorators);\n    } else {\n      clazz.decorators = decorators;\n    }\n  }\n  if (ctorParameters !== null) {\n    // Rather than merging, clobber the existing parameters. If other projects exist which use\n    // tsickle-style annotations and reflect over them in the same way, this could cause issues,\n    // but that is vanishingly unlikely.\n    clazz.ctorParameters = ctorParameters;\n  }\n  if (propDecorators !== null) {\n    // The property decorator objects are merged as it is possible different fields have different\n    // decorator types. Decorators on individual fields are not merged, as it's also incredibly\n    // unlikely that a field will be decorated both with an Angular decorator and a non-Angular\n    // decorator that's also been downleveled.\n    if (clazz.propDecorators !== undefined) {\n      clazz.propDecorators = {...clazz.propDecorators, ...propDecorators};\n    } else {\n      clazz.propDecorators = propDecorators;\n    }\n  }\n}\n"]}