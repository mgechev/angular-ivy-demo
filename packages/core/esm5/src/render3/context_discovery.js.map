{"version":3,"file":"context_discovery.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/context_discovery.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport './ng_dev_mode';\n\nimport {assertDomNode} from './assert';\nimport {EMPTY_ARRAY} from './definition';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from './interfaces/context';\nimport {TNode, TNodeFlags} from './interfaces/node';\nimport {RElement} from './interfaces/renderer';\nimport {CONTEXT, HEADER_OFFSET, HOST, LView, TVIEW} from './interfaces/view';\nimport {getComponentViewByIndex, getNativeByTNode, readElementValue, readPatchedData} from './util';\n\n\n\n/** Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nexport function getContext(target: any): LContext|null {\n  let mpValue = readPatchedData(target);\n  if (mpValue) {\n    // only when it's an array is it considered an LView instance\n    // ... otherwise it's an already constructed LContext instance\n    if (Array.isArray(mpValue)) {\n      const lView: LView = mpValue !;\n      let nodeIndex: number;\n      let component: any = undefined;\n      let directives: any[]|null|undefined = undefined;\n\n      if (isComponentInstance(target)) {\n        nodeIndex = findViaComponent(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided component was not found in the application');\n        }\n        component = target;\n      } else if (isDirectiveInstance(target)) {\n        nodeIndex = findViaDirective(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided directive was not found in the application');\n        }\n        directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\n      } else {\n        nodeIndex = findViaNativeElement(lView, target as RElement);\n        if (nodeIndex == -1) {\n          return null;\n        }\n      }\n\n      // the goal is not to fill the entire context full of data because the lookups\n      // are expensive. Instead, only the target data (the element, compontent or\n      // directive details) are filled into the context. If called multiple times\n      // with different target values then the missing target data will be filled in.\n      const native = readElementValue(lView[nodeIndex]);\n      const existingCtx = readPatchedData(native);\n      const context: LContext = (existingCtx && !Array.isArray(existingCtx)) ?\n          existingCtx :\n          createLContext(lView, nodeIndex, native);\n\n      // only when the component has been discovered then update the monkey-patch\n      if (component && context.component === undefined) {\n        context.component = component;\n        attachPatchData(context.component, context);\n      }\n\n      // only when the directives have been discovered then update the monkey-patch\n      if (directives && context.directives === undefined) {\n        context.directives = directives;\n        for (let i = 0; i < directives.length; i++) {\n          attachPatchData(directives[i], context);\n        }\n      }\n\n      attachPatchData(context.native, context);\n      mpValue = context;\n    }\n  } else {\n    const rElement = target as RElement;\n    ngDevMode && assertDomNode(rElement);\n\n    // if the context is not found then we need to traverse upwards up the DOM\n    // to find the nearest element that has already been monkey patched with data\n    let parent = rElement as any;\n    while (parent = parent.parentNode) {\n      const parentContext = readPatchedData(parent);\n      if (parentContext) {\n        let lView: LView|null;\n        if (Array.isArray(parentContext)) {\n          lView = parentContext as LView;\n        } else {\n          lView = parentContext.lView;\n        }\n\n        // the edge of the app was also reached here through another means\n        // (maybe because the DOM was changed manually).\n        if (!lView) {\n          return null;\n        }\n\n        const index = findViaNativeElement(lView, rElement);\n        if (index >= 0) {\n          const native = readElementValue(lView[index]);\n          const context = createLContext(lView, index, native);\n          attachPatchData(native, context);\n          mpValue = context;\n          break;\n        }\n      }\n    }\n  }\n  return (mpValue as LContext) || null;\n}\n\n/**\n * Creates an empty instance of a `LContext` context\n */\nfunction createLContext(lView: LView, nodeIndex: number, native: RElement): LContext {\n  return {\n    lView,\n    nodeIndex,\n    native,\n    component: undefined,\n    directives: undefined,\n    localRefs: undefined,\n  };\n}\n\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nexport function getComponentViewByInstance(componentInstance: {}): LView {\n  let lView = readPatchedData(componentInstance);\n  let view: LView;\n\n  if (Array.isArray(lView)) {\n    const nodeIndex = findViaComponent(lView, componentInstance);\n    view = getComponentViewByIndex(nodeIndex, lView);\n    const context = createLContext(lView, nodeIndex, view[HOST] as RElement);\n    context.component = componentInstance;\n    attachPatchData(componentInstance, context);\n    attachPatchData(context.native, context);\n  } else {\n    const context = lView as any as LContext;\n    view = getComponentViewByIndex(context.nodeIndex, context.lView);\n  }\n  return view;\n}\n\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nexport function attachPatchData(target: any, data: LView | LContext) {\n  target[MONKEY_PATCH_KEY_NAME] = data;\n}\n\nexport function isComponentInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.ngComponentDef;\n}\n\nexport function isDirectiveInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.ngDirectiveDef;\n}\n\n/**\n * Locates the element within the given LView and returns the matching index\n */\nfunction findViaNativeElement(lView: LView, target: RElement): number {\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const native = getNativeByTNode(tNode, lView) !;\n    if (native === target) {\n      return tNode.index;\n    }\n    tNode = traverseNextElement(tNode);\n  }\n\n  return -1;\n}\n\n/**\n * Locates the next tNode (child, sibling or parent).\n */\nfunction traverseNextElement(tNode: TNode): TNode|null {\n  if (tNode.child) {\n    return tNode.child;\n  } else if (tNode.next) {\n    return tNode.next;\n  } else if (tNode.parent) {\n    return tNode.parent.next || null;\n  }\n  return null;\n}\n\n/**\n * Locates the component within the given LView and returns the matching index\n */\nfunction findViaComponent(lView: LView, componentInstance: {}): number {\n  const componentIndices = lView[TVIEW].components;\n  if (componentIndices) {\n    for (let i = 0; i < componentIndices.length; i++) {\n      const elementComponentIndex = componentIndices[i];\n      const componentView = getComponentViewByIndex(elementComponentIndex, lView);\n      if (componentView[CONTEXT] === componentInstance) {\n        return elementComponentIndex;\n      }\n    }\n  } else {\n    const rootComponentView = getComponentViewByIndex(HEADER_OFFSET, lView);\n    const rootComponent = rootComponentView[CONTEXT];\n    if (rootComponent === componentInstance) {\n      // we are dealing with the root element here therefore we know that the\n      // element is the very first element after the HEADER data in the lView\n      return HEADER_OFFSET;\n    }\n  }\n  return -1;\n}\n\n/**\n * Locates the directive within the given LView and returns the matching index\n */\nfunction findViaDirective(lView: LView, directiveInstance: {}): number {\n  // if a directive is monkey patched then it will (by default)\n  // have a reference to the LView of the current view. The\n  // element bound to the directive being search lives somewhere\n  // in the view data. We loop through the nodes and check their\n  // list of directives for the instance.\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const directiveIndexStart = getDirectiveStartIndex(tNode);\n    const directiveIndexEnd = getDirectiveEndIndex(tNode, directiveIndexStart);\n    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n      if (lView[i] === directiveInstance) {\n        return tNode.index;\n      }\n    }\n    tNode = traverseNextElement(tNode);\n  }\n  return -1;\n}\n\n/**\n * Returns a list of directives extracted from the given view based on the\n * provided list of directive index values.\n *\n * @param nodeIndex The node index\n * @param lView The target view data\n * @param includeComponents Whether or not to include components in returned directives\n */\nexport function getDirectivesAtNodeIndex(\n    nodeIndex: number, lView: LView, includeComponents: boolean): any[]|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  let directiveStartIndex = getDirectiveStartIndex(tNode);\n  if (directiveStartIndex == 0) return EMPTY_ARRAY;\n  const directiveEndIndex = getDirectiveEndIndex(tNode, directiveStartIndex);\n  if (!includeComponents && tNode.flags & TNodeFlags.isComponent) directiveStartIndex++;\n  return lView.slice(directiveStartIndex, directiveEndIndex);\n}\n\nexport function getComponentAtNodeIndex(nodeIndex: number, lView: LView): {}|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  let directiveStartIndex = getDirectiveStartIndex(tNode);\n  return tNode.flags & TNodeFlags.isComponent ? lView[directiveStartIndex] : null;\n}\n\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nexport function discoverLocalRefs(lView: LView, nodeIndex: number): {[key: string]: any}|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  if (tNode && tNode.localNames) {\n    const result: {[key: string]: any} = {};\n    for (let i = 0; i < tNode.localNames.length; i += 2) {\n      const localRefName = tNode.localNames[i];\n      const directiveIndex = tNode.localNames[i + 1] as number;\n      result[localRefName] =\n          directiveIndex === -1 ? getNativeByTNode(tNode, lView) ! : lView[directiveIndex];\n    }\n    return result;\n  }\n\n  return null;\n}\n\nfunction getDirectiveStartIndex(tNode: TNode): number {\n  // the tNode instances store a flag value which then has a\n  // pointer which tells the starting index of where all the\n  // active directives are in the master directive array\n  return tNode.flags >> TNodeFlags.DirectiveStartingIndexShift;\n}\n\nfunction getDirectiveEndIndex(tNode: TNode, startIndex: number): number {\n  // The end value is also a part of the same flag\n  // (see `TNodeFlags` to see how the flag bit shifting\n  // values are used).\n  const count = tNode.flags & TNodeFlags.DirectiveCountMask;\n  return count ? (startIndex + count) : -1;\n}\n"]}