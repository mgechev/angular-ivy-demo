{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../../../../packages/core/src/render3/styling/util.ts"],"names":[],"mappings":";;;;AAOA,OAAO,gBAAgB,CAAC;AAGxB,OAAO,EAAC,UAAU,EAAC,MAAM,sBAAsB,CAAC;AAChD,OAAO,EAAC,YAAY,EAAa,MAAM,yBAAyB,CAAC;AAKjE,OAAO,EAAC,KAAK,EAAE,aAAa,EAAE,IAAI,EAAqB,MAAM,oBAAoB,CAAC;AAClF,OAAO,EAAC,QAAQ,EAAC,MAAM,SAAS,CAAC;AAEjC,OAAO,EAAC,iBAAiB,EAAC,MAAM,uBAAuB,CAAC;;;;;;;AAExD,MAAM,UAAU,yBAAyB,CACrC,OAAyB,EAAE,SAAkC,EAC7D,oBAAoC;IACtC,OAAO;QACL,IAAI;;QACJ,SAAS,IAAI,IAAI;;QACjB,oBAAoB,IAAI,CAAC,IAAI,CAAC;QAC9B,CAAC;QACD,CAAC;;QACD,OAAO,IAAI,IAAI;QACf,IAAI;QACJ,IAAI;KACL,CAAC;CACH;;;;;;;;;;AAQD,MAAM,UAAU,mBAAmB,CAC/B,OAAwB,EAAE,oBAAoC;;IAEhE,IAAM,OAAO,sBAAG,oBAAoB,CAAC,KAAK,EAAS,GAAmB;IACtE,OAAO,yBAA8B,GAAG,OAAO,CAAC;IAChD,OAAO,OAAO,CAAC;CAChB;;;;;;;;;;;;;AAaD,MAAM,UAAU,iBAAiB,CAAC,KAAa,EAAE,QAAe;;IAC9D,IAAI,YAAY,GAAG,KAAK,GAAG,aAAa,CAAC;;IACzC,IAAI,SAAS,GAA6C,QAAQ,CAAC,YAAY,CAAC,CAAC;;IACjF,IAAI,OAAO,GAAoC,QAAQ,CAAC;IAExD,OAAO,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;QAC/B,OAAO,GAAG,SAAS,CAAC;QACpB,SAAS,qBAAG,SAAS,CAAC,IAAI,CAAsC,CAAA,CAAC;KAClE;IAED,IAAI,gBAAgB,CAAC,OAAO,CAAC,EAAE;QAC7B,yBAAO,OAAyB,EAAC;KAClC;SAAM;;QAEL,IAAM,eAAe,GAAG,QAAQ,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,eAAe,CAAC;QAElE,IAAI,OAAO,KAAK,QAAQ,EAAE;YACxB,YAAY,GAAG,IAAI,CAAC;SACrB;QAED,OAAO,OAAO,CAAC,YAAY,CAAC,GAAG,eAAe,CAAC,CAAC;YAC5C,mBAAmB,CAAC,SAAS,EAAE,eAAe,CAAC,CAAC,CAAC;YACjD,yBAAyB,CAAC,SAAS,CAAC,CAAC;KAC1C;CACF;;;;;AAED,SAAS,gBAAgB,CAAC,KAA0C;;IAElE,OAAO,OAAO,KAAK,CAAC,KAAK,CAAC,KAAK,QAAQ,IAAI,OAAO,KAAK,CAAC,YAAY,CAAC,KAAK,QAAQ,CAAC;CACpF;;;;;;;;;;AAED,MAAM,UAAU,iBAAiB,CAC7B,aAA4B,EAAE,WAAwB,EAAE,OAAoB,EAC5E,MAAqB,EAAE,kBAA0B,EAAE,GAAS;IAC9D,GAAG,GAAG,GAAG,IAAI,OAAO,CAAC;IACrB,IAAI,kBAAkB,EAAE;QACtB,aAAa,CAAC,kBAAkB,CAAC,GAAG,MAAM,CAAC;KAC5C;SAAM;QACL,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;KAC5B;IAED,IAAI,MAAM,EAAE;QACV,MAAM,CAAC,gBAAgB,sBAAsB;;YAC3C,IAAM,KAAK,GAAG,aAAa,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;;YAC5C,IAAM,qBAAqB,GAAG,aAAa,gCAAoC,CAAC;;;;;YAMhF,IAAI,KAAK,EAAE;gBACT,IAAI,KAAK,GAAG,qBAAqB,EAAE;oBACjC,aAAa,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;iBAC7B;qBAAM;oBACL,aAAa,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;iBAChC;aACF;YACD,MAAM,CAAC,OAAO,EAAE,CAAC;SAClB,CAAC,CAAC;;QAEH,IAAM,aAAa,GACf,WAAW,CAAC,aAAa,IAAI,CAAC,WAAW,CAAC,aAAa,GAAG,IAAI,iBAAiB,EAAE,CAAC,CAAC;QACvF,aAAa,CAAC,WAAW,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QACvC,OAAO,IAAI,CAAC;KACb;IAED,OAAO,KAAK,CAAC;CACd;;;;;AAED,MAAM,UAAU,kBAAkB,CAAC,aAA4B;;IAC7D,IAAM,OAAO,GAAa,EAAE,CAAC;;IAC7B,IAAM,sBAAsB,GAAG,aAAa,gCAAoC,CAAC;;IAGjF,KAAK,IAAI,CAAC,GAAG,kEAA0E,EAClF,CAAC,GAAG,sBAAsB,EAAE,CAAC,4CAAgD,EAAE;;QAClF,IAAM,MAAM,qBAAG,aAAa,CAAC,CAAC,CAAkB,EAAC;QACjD,IAAI,MAAM,EAAE;YACV,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SACtB;KACF;;IAGD,KAAK,IAAI,CAAC,GAAG,sBAAsB,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAClE,OAAO,CAAC,IAAI,mBAAC,aAAa,CAAC,CAAC,CAAW,EAAC,CAAC;KAC1C;IAED,OAAO,OAAO,CAAC;CAChB;;;;;;AAGD,MAAM,UAAU,wBAAwB,CAAC,MAAU,EAAE,OAAyB;IAE5E,OAAO,GAAG,OAAO,uBAAI,UAAU,CAAC,MAAM,CAAC,EAAE,CAAC;IAC1C,IAAI,CAAC,OAAO,EAAE;QACZ,SAAS,IAAI,oBAAoB,EAAE,CAAC;QACpC,OAAO,IAAI,CAAC;KACb;IAEM,IAAA,qBAAK,EAAE,6BAAS,CAAY;;IACnC,IAAM,cAAc,GAAG,iBAAiB,CAAC,SAAS,GAAG,aAAa,EAAE,KAAK,CAAC,CAAC;IAC3E,OAAO,gBAAgB,CAAC,cAAc,CAAC,IAAI,kBAAkB,CAAC,cAAc,CAAC,CAAC;CAC/E;;;;;AAED,MAAM,UAAU,gBAAgB,CAAC,cAA8B;IAC7D,OAAO,cAAc,uBAA4B,CAAC;CACnD;;;;;AAED,MAAM,UAAU,kBAAkB,CAAC,IAAoB;IACrD,OAAO,IAAI,uBAA4B;QAC5B,4CAAgD,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;CACpF;;;;AAED,MAAM,UAAU,oBAAoB;IAClC,MAAM,IAAI,KAAK,CAAC,+EAA+E,CAAC,CAAC;CAClG","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../ng_dev_mode';\n\nimport {StyleSanitizeFn} from '../../sanitization/style_sanitizer';\nimport {getContext} from '../context_discovery';\nimport {ACTIVE_INDEX, LContainer} from '../interfaces/container';\nimport {LContext} from '../interfaces/context';\nimport {PlayState, Player, PlayerContext, PlayerIndex} from '../interfaces/player';\nimport {RElement} from '../interfaces/renderer';\nimport {InitialStyles, StylingContext, StylingIndex} from '../interfaces/styling';\nimport {FLAGS, HEADER_OFFSET, HOST, LView, RootContext} from '../interfaces/view';\nimport {getTNode} from '../util';\n\nimport {CorePlayerHandler} from './core_player_handler';\n\nexport function createEmptyStylingContext(\n    element?: RElement | null, sanitizer?: StyleSanitizeFn | null,\n    initialStylingValues?: InitialStyles): StylingContext {\n  return [\n    null,                            // PlayerContext\n    sanitizer || null,               // StyleSanitizer\n    initialStylingValues || [null],  // InitialStyles\n    0,                               // MasterFlags\n    0,                               // ClassOffset\n    element || null,                 // Element\n    null,                            // PreviousMultiClassValue\n    null                             // PreviousMultiStyleValue\n  ];\n}\n\n/**\n * Used clone a copy of a pre-computed template of a styling context.\n *\n * A pre-computed template is designed to be computed once for a given element\n * (instructions.ts has logic for caching this).\n */\nexport function allocStylingContext(\n    element: RElement | null, templateStyleContext: StylingContext): StylingContext {\n  // each instance gets a copy\n  const context = templateStyleContext.slice() as any as StylingContext;\n  context[StylingIndex.ElementPosition] = element;\n  return context;\n}\n\n/**\n * Retrieve the `StylingContext` at a given index.\n *\n * This method lazily creates the `StylingContext`. This is because in most cases\n * we have styling without any bindings. Creating `StylingContext` eagerly would mean that\n * every style declaration such as `<div style=\"color: red\">` would result `StyleContext`\n * which would create unnecessary memory pressure.\n *\n * @param index Index of the style allocation. See: `elementStyling`.\n * @param viewData The view to search for the styling context\n */\nexport function getStylingContext(index: number, viewData: LView): StylingContext {\n  let storageIndex = index + HEADER_OFFSET;\n  let slotValue: LContainer|LView|StylingContext|RElement = viewData[storageIndex];\n  let wrapper: LContainer|LView|StylingContext = viewData;\n\n  while (Array.isArray(slotValue)) {\n    wrapper = slotValue;\n    slotValue = slotValue[HOST] as LView | StylingContext | RElement;\n  }\n\n  if (isStylingContext(wrapper)) {\n    return wrapper as StylingContext;\n  } else {\n    // This is an LView or an LContainer\n    const stylingTemplate = getTNode(index, viewData).stylingTemplate;\n\n    if (wrapper !== viewData) {\n      storageIndex = HOST;\n    }\n\n    return wrapper[storageIndex] = stylingTemplate ?\n        allocStylingContext(slotValue, stylingTemplate) :\n        createEmptyStylingContext(slotValue);\n  }\n}\n\nfunction isStylingContext(value: LView | LContainer | StylingContext) {\n  // Not an LView or an LContainer\n  return typeof value[FLAGS] !== 'number' && typeof value[ACTIVE_INDEX] !== 'number';\n}\n\nexport function addPlayerInternal(\n    playerContext: PlayerContext, rootContext: RootContext, element: HTMLElement,\n    player: Player | null, playerContextIndex: number, ref?: any): boolean {\n  ref = ref || element;\n  if (playerContextIndex) {\n    playerContext[playerContextIndex] = player;\n  } else {\n    playerContext.push(player);\n  }\n\n  if (player) {\n    player.addEventListener(PlayState.Destroyed, () => {\n      const index = playerContext.indexOf(player);\n      const nonFactoryPlayerIndex = playerContext[PlayerIndex.NonBuilderPlayersStart];\n\n      // if the player is being removed from the factory side of the context\n      // (which is where the [style] and [class] bindings do their thing) then\n      // that side of the array cannot be resized since the respective bindings\n      // have pointer index values that point to the associated factory instance\n      if (index) {\n        if (index < nonFactoryPlayerIndex) {\n          playerContext[index] = null;\n        } else {\n          playerContext.splice(index, 1);\n        }\n      }\n      player.destroy();\n    });\n\n    const playerHandler =\n        rootContext.playerHandler || (rootContext.playerHandler = new CorePlayerHandler());\n    playerHandler.queuePlayer(player, ref);\n    return true;\n  }\n\n  return false;\n}\n\nexport function getPlayersInternal(playerContext: PlayerContext): Player[] {\n  const players: Player[] = [];\n  const nonFactoryPlayersStart = playerContext[PlayerIndex.NonBuilderPlayersStart];\n\n  // add all factory-based players (which are apart of [style] and [class] bindings)\n  for (let i = PlayerIndex.PlayerBuildersStartPosition + PlayerIndex.PlayerOffsetPosition;\n       i < nonFactoryPlayersStart; i += PlayerIndex.PlayerAndPlayerBuildersTupleSize) {\n    const player = playerContext[i] as Player | null;\n    if (player) {\n      players.push(player);\n    }\n  }\n\n  // add all custom players (not apart of [style] and [class] bindings)\n  for (let i = nonFactoryPlayersStart; i < playerContext.length; i++) {\n    players.push(playerContext[i] as Player);\n  }\n\n  return players;\n}\n\n\nexport function getOrCreatePlayerContext(target: {}, context?: LContext | null): PlayerContext|\n    null {\n  context = context || getContext(target) !;\n  if (!context) {\n    ngDevMode && throwInvalidRefError();\n    return null;\n  }\n\n  const {lView, nodeIndex} = context;\n  const stylingContext = getStylingContext(nodeIndex - HEADER_OFFSET, lView);\n  return getPlayerContext(stylingContext) || allocPlayerContext(stylingContext);\n}\n\nexport function getPlayerContext(stylingContext: StylingContext): PlayerContext|null {\n  return stylingContext[StylingIndex.PlayerContext];\n}\n\nexport function allocPlayerContext(data: StylingContext): PlayerContext {\n  return data[StylingIndex.PlayerContext] =\n             [PlayerIndex.SinglePlayerBuildersStartPosition, null, null, null, null];\n}\n\nexport function throwInvalidRefError() {\n  throw new Error('Only elements that exist in an Angular application can be used for animations');\n}\n"]}