{"version":3,"file":"di_setup.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/di_setup.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {resolveForwardRef} from '../di/forward_ref';\nimport {Provider} from '../di/provider';\nimport {isTypeProvider, providerToFactory} from '../di/r3_injector';\n\nimport {DirectiveDef} from '.';\nimport {diPublicInInjector, getNodeInjectable, getOrCreateNodeInjectorForNode} from './di';\nimport {directiveInject} from './instructions';\nimport {NodeInjectorFactory} from './interfaces/injector';\nimport {TContainerNode, TElementContainerNode, TElementNode, TNodeFlags, TNodeProviderIndexes} from './interfaces/node';\nimport {LView, TData, TVIEW, TView} from './interfaces/view';\nimport {getLView, getPreviousOrParentTNode} from './state';\nimport {isComponentDef} from './util';\n\n\n\n/**\n * Resolves the providers which are defined in the DirectiveDef.\n *\n * When inserting the tokens and the factories in their respective arrays, we can assume that\n * this method is called first for the component (if any), and then for other directives on the same\n * node.\n * As a consequence,the providers are always processed in that order:\n * 1) The view providers of the component\n * 2) The providers of the component\n * 3) The providers of the other directives\n * This matches the structure of the injectables arrays of a view (for each node).\n * So the tokens and the factories can be pushed at the end of the arrays, except\n * in one case for multi providers.\n *\n * @param def the directive definition\n * @param providers: Array of `providers`.\n * @param viewProviders: Array of `viewProviders`.\n */\nexport function providersResolver<T>(\n    def: DirectiveDef<T>, providers: Provider[], viewProviders: Provider[]): void {\n  const lView = getLView();\n  const tView: TView = lView[TVIEW];\n  if (tView.firstTemplatePass) {\n    const isComponent = isComponentDef(def);\n\n    // The list of view providers is processed first, and the flags are updated\n    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent, true);\n\n    // Then, the list of providers is processed, and the flags are updated\n    resolveProvider(providers, tView.data, tView.blueprint, isComponent, false);\n  }\n}\n\n/**\n * Resolves a provider and publishes it to the DI system.\n */\nfunction resolveProvider(\n    provider: Provider, tInjectables: TData, lInjectablesBlueprint: NodeInjectorFactory[],\n    isComponent: boolean, isViewProvider: boolean): void {\n  provider = resolveForwardRef(provider);\n  if (Array.isArray(provider)) {\n    // Recursively call `resolveProvider`\n    // Recursion is OK in this case because this code will not be in hot-path once we implement\n    // cloning of the initial state.\n    for (let i = 0; i < provider.length; i++) {\n      resolveProvider(\n          provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);\n    }\n  } else {\n    const lView = getLView();\n    let token: any = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n    let providerFactory: () => any = providerToFactory(provider);\n\n    const previousOrParentTNode = getPreviousOrParentTNode();\n    const beginIndex =\n        previousOrParentTNode.providerIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n    const endIndex = previousOrParentTNode.flags >> TNodeFlags.DirectiveStartingIndexShift;\n    const cptViewProvidersCount =\n        previousOrParentTNode.providerIndexes >> TNodeProviderIndexes.CptViewProvidersCountShift;\n\n    if (isTypeProvider(provider) || !provider.multi) {\n      // Single provider case: the factory is created and pushed immediately\n      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, directiveInject);\n      const existingFactoryIndex = indexOf(\n          token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount,\n          endIndex);\n      if (existingFactoryIndex == -1) {\n        diPublicInInjector(\n            getOrCreateNodeInjectorForNode(\n                previousOrParentTNode as TElementNode | TContainerNode | TElementContainerNode,\n                lView),\n            lView, token);\n        tInjectables.push(token);\n        previousOrParentTNode.flags += 1 << TNodeFlags.DirectiveStartingIndexShift;\n        if (isViewProvider) {\n          previousOrParentTNode.providerIndexes +=\n              TNodeProviderIndexes.CptViewProvidersCountShifter;\n        }\n        lInjectablesBlueprint.push(factory);\n        lView.push(factory);\n      } else {\n        lInjectablesBlueprint[existingFactoryIndex] = factory;\n        lView[existingFactoryIndex] = factory;\n      }\n    } else {\n      // Multi provider case:\n      // We create a multi factory which is going to aggregate all the values.\n      // Since the output of such a factory depends on content or view injection,\n      // we create two of them, which are linked together.\n      //\n      // The first one (for view providers) is always in the first block of the injectables array,\n      // and the second one (for providers) is always in the second block.\n      // This is important because view providers have higher priority. When a multi token\n      // is being looked up, the view providers should be found first.\n      // Note that it is not possible to have a multi factory in the third block (directive block).\n      //\n      // The algorithm to process multi providers is as follows:\n      // 1) If the multi provider comes from the `viewProviders` of the component:\n      //   a) If the special view providers factory doesn't exist, it is created and pushed.\n      //   b) Else, the multi provider is added to the existing multi factory.\n      // 2) If the multi provider comes from the `providers` of the component or of another\n      // directive:\n      //   a) If the multi factory doesn't exist, it is created and provider pushed into it.\n      //      It is also linked to the multi factory for view providers, if it exists.\n      //   b) Else, the multi provider is added to the existing multi factory.\n\n      const existingProvidersFactoryIndex =\n          indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);\n      const existingViewProvidersFactoryIndex =\n          indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);\n      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 &&\n          lInjectablesBlueprint[existingProvidersFactoryIndex];\n      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 &&\n          lInjectablesBlueprint[existingViewProvidersFactoryIndex];\n\n      if (isViewProvider && !doesViewProvidersFactoryExist ||\n          !isViewProvider && !doesProvidersFactoryExist) {\n        // Cases 1.a and 2.a\n        diPublicInInjector(\n            getOrCreateNodeInjectorForNode(\n                previousOrParentTNode as TElementNode | TContainerNode | TElementContainerNode,\n                lView),\n            lView, token);\n        const factory = multiFactory(\n            isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver,\n            lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);\n        if (!isViewProvider && doesViewProvidersFactoryExist) {\n          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;\n        }\n        tInjectables.push(token);\n        previousOrParentTNode.flags += 1 << TNodeFlags.DirectiveStartingIndexShift;\n        if (isViewProvider) {\n          previousOrParentTNode.providerIndexes +=\n              TNodeProviderIndexes.CptViewProvidersCountShifter;\n        }\n        lInjectablesBlueprint.push(factory);\n        lView.push(factory);\n      } else {\n        // Cases 1.b and 2.b\n        multiFactoryAdd(\n            lInjectablesBlueprint ![isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex],\n            providerFactory, !isViewProvider && isComponent);\n      }\n      if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {\n        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders !++;\n      }\n    }\n  }\n}\n\n/**\n * Add a factory in a multi factory.\n */\nfunction multiFactoryAdd(\n    multiFactory: NodeInjectorFactory, factory: () => any, isComponentProvider: boolean): void {\n  multiFactory.multi !.push(factory);\n  if (isComponentProvider) {\n    multiFactory.componentProviders !++;\n  }\n}\n\n/**\n * Returns the index of item in the array, but only in the begin to end range.\n */\nfunction indexOf(item: any, arr: any[], begin: number, end: number) {\n  for (let i = begin; i < end; i++) {\n    if (arr[i] === item) return i;\n  }\n  return -1;\n}\n\n/**\n * Use this with `multi` `providers`.\n */\nfunction multiProvidersFactoryResolver(\n    this: NodeInjectorFactory, _: null, tData: TData, lData: LView, tNode: TElementNode): any[] {\n  return multiResolve(this.multi !, []);\n}\n\n/**\n * Use this with `multi` `viewProviders`.\n *\n * This factory knows how to concatenate itself with the existing `multi` `providers`.\n */\nfunction multiViewProvidersFactoryResolver(\n    this: NodeInjectorFactory, _: null, tData: TData, lData: LView, tNode: TElementNode): any[] {\n  const factories = this.multi !;\n  let result: any[];\n  if (this.providerFactory) {\n    const componentCount = this.providerFactory.componentProviders !;\n    const multiProviders = getNodeInjectable(tData, lData, this.providerFactory !.index !, tNode);\n    // Copy the section of the array which contains `multi` `providers` from the component\n    result = multiProviders.slice(0, componentCount);\n    // Insert the `viewProvider` instances.\n    multiResolve(factories, result);\n    // Copy the section of the array which contains `multi` `providers` from other directives\n    for (let i = componentCount; i < multiProviders.length; i++) {\n      result.push(multiProviders[i]);\n    }\n  } else {\n    result = [];\n    // Insert the `viewProvider` instances.\n    multiResolve(factories, result);\n  }\n  return result;\n}\n\n/**\n * Maps an array of factories into an array of values.\n */\nfunction multiResolve(factories: Array<() => any>, result: any[]): any[] {\n  for (let i = 0; i < factories.length; i++) {\n    const factory = factories[i] !as() => null;\n    result.push(factory());\n  }\n  return result;\n}\n\n/**\n * Creates a multi factory.\n */\nfunction multiFactory(\n    factoryFn: (\n        this: NodeInjectorFactory, _: null, tData: TData, lData: LView, tNode: TElementNode) => any,\n    index: number, isViewProvider: boolean, isComponent: boolean,\n    f: () => any): NodeInjectorFactory {\n  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, directiveInject);\n  factory.multi = [];\n  factory.index = index;\n  factory.componentProviders = 0;\n  multiFactoryAdd(factory, f, isComponent && !isViewProvider);\n  return factory;\n}\n"]}